// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// # Introduction
/// Welcome to the reference for the Lichess API! Lichess is free/libre,
/// open-source chess server powered by volunteers and donations.
/// - Get help in the [Lichess Discord channel](https://discord.gg/lichess)
/// - API demo app with OAuth2 login and gameplay: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/)
/// - API UI app with OAuth2 login and endpoint forms: [source](https://github.com/lichess-org/api-ui) / [website](https://lichess.org/api/ui)
/// - [Contribute to this documentation on Github](https://github.com/lichess-org/api)
/// - Check out [Lichess widgets to embed in your website](https://lichess.org/developers)
/// - [Download all Lichess rated games](https://database.lichess.org/)
/// - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)
/// - [Download all evaluated positions](https://database.lichess.org/#evals)
///
/// ## Endpoint
/// All requests go to `https://lichess.org` (unless otherwise specified).
///
/// ## Clients
/// - [Python general API](https://github.com/lichess-org/berserk)
/// - [MicroPython general API](https://github.com/mkomon/uberserk)
/// - [Python general API - async](https://pypi.org/project/async-lichess-sdk)
/// - [Python Lichess Bot](https://github.com/lichess-bot-devs/lichess-bot)
/// - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess)
/// - [Java general API](https://github.com/tors42/chariot)
/// - [JavaScript & TypeScript general API](https://github.com/devjiwonchoi/equine)
/// - [LichessNET - C# API Wrapper](https://github.com/Rabergsel/LichessNET)
///
/// ## Rate limiting
/// All requests are rate limited using various strategies,
/// to ensure the API remains responsive for everyone.
/// Only make one request at a time.
/// If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429),
/// please wait a full minute before resuming API usage.
///
/// ## Streaming with ND-JSON
/// Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](https://github.com/ndjson/ndjson-spec), with one JSON object per line.
///
/// Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses.
///
/// ## Authentication
/// ### Which authentication method is right for me?
/// [Read about the Lichess API authentication methods and code examples](https://github.com/lichess-org/api/blob/master/example/README.md)
///
/// ### Personal Access Token
/// Personal API access tokens allow you to quickly interact with Lichess API without going through an OAuth flow.
/// - [Generate a personal access token](https://lichess.org/account/oauth/token)
/// - `curl https://lichess.org/api/account -H "Authorization: Bearer {token}"`
/// - [NodeJS example](https://github.com/lichess-org/api/tree/master/example/oauth-personal-token)
///
/// ### Token Security
/// - Keep your tokens secret. Do not share them in public repositories or public forums.
/// - Your tokens can be used to make your account perform arbitrary actions (within the limits of the tokens' scope). You remain responsible for all activities on your account.
/// - Do not hardcode tokens in your application's code. Use environment variables or a secure storage and ensure they are not shipped/exposed to users. Be especially careful that they are not included in frontend bundles or apps that are shipped to users.
/// - If you suspect a token has been compromised, revoke it immediately.
///
/// To see your active tokens or revoke them, see [your Personal API access tokens](https://lichess.org/account/oauth/token).
///
/// ### Authorization Code Flow with PKCE
/// The authorization code flow with PKCE allows your users to **login with Lichess**.
/// Lichess supports unregistered and public clients (no client authentication, choose any unique client id).
/// The only accepted code challenge method is `S256`.
/// Access tokens are long-lived (expect one year), unless they are revoked.
/// Refresh tokens are not supported.
///
/// See the [documentation for the OAuth endpoints](#tag/OAuth) or
/// the [PKCE RFC](https://datatracker.ietf.org/doc/html/rfc7636#section-4) for a precise protocol description.
///
/// - [Demo app](https://lichess-org.github.io/api-demo/)
/// - [Minimal client-side example](https://github.com/lichess-org/api/tree/master/example/oauth-app)
/// - [Flask/Python example](https://github.com/lakinwecker/lichess-oauth-flask)
/// - [Java example](https://github.com/tors42/lichess-oauth-pkce-app)
/// - [NodeJS Passport strategy to login with Lichess OAuth2](https://www.npmjs.com/package/passport-lichess)
///
/// #### Real life examples
/// - [PyChess](https://github.com/gbtami/pychess-variants) ([source code](https://github.com/gbtami/pychess-variants))
/// - [Lichess4545](https://www.lichess4545.com/) ([source code](https://github.com/cyanfish/heltour))
/// - [English Chess Federation](https://ecf.octoknight.com/)
/// - [Rotherham Online Chess](https://rotherhamonlinechess.azurewebsites.net/tournaments)
///
/// ### Token format
/// Access tokens and authorization codes match `^[A-Za-z0-9_]+$`.
/// The length of tokens can be increased without notice. Make sure your application can handle at least 512 characters.
/// By convention tokens have a recognizable prefix, but do not rely on this.
///
internal struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get real-time users status
    ///
    /// Read the `online`, `playing` and `streaming` flags of several users.
    /// This API is very fast and cheap on lichess side.
    /// So you can call it quite often (like once every 5 seconds).
    /// Use it to track players and know when they're connected on lichess and playing games.
    ///
    ///
    /// - Remark: HTTP `GET /api/users/status`.
    /// - Remark: Generated from `#/paths//api/users/status/get(apiUsersStatus)`.
    internal func apiUsersStatus(_ input: Operations.apiUsersStatus.Input) async throws -> Operations.apiUsersStatus.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUsersStatus.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/users/status",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ids",
                    value: input.query.ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "withSignal",
                    value: input.query.withSignal
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "withGameIds",
                    value: input.query.withGameIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "withGameMetas",
                    value: input.query.withGameMetas
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUsersStatus.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUsersStatus.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiUsersStatus.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get all top 10
    ///
    /// Get the top 10 players for each speed and variant.
    /// See <https://lichess.org/player>.
    ///
    ///
    /// - Remark: HTTP `GET /api/player`.
    /// - Remark: Generated from `#/paths//api/player/get(player)`.
    internal func player(_ input: Operations.player.Input) async throws -> Operations.player.Output {
        try await client.send(
            input: input,
            forOperation: Operations.player.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/player",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.player.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.player.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Top10s.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get one leaderboard
    ///
    /// Get the leaderboard for a single speed or variant (a.k.a. `perfType`).
    /// There is no leaderboard for correspondence or puzzles.
    /// See <https://lichess.org/player/top/200/bullet>.
    ///
    ///
    /// - Remark: HTTP `GET /api/player/top/{nb}/{perfType}`.
    /// - Remark: Generated from `#/paths//api/player/top/{nb}/{perfType}/get(playerTopNbPerfType)`.
    internal func playerTopNbPerfType(_ input: Operations.playerTopNbPerfType.Input) async throws -> Operations.playerTopNbPerfType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.playerTopNbPerfType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/player/top/{}/{}",
                    parameters: [
                        input.path.nb,
                        input.path.perfType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.playerTopNbPerfType.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.playerTopNbPerfType.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/vnd.lichess.v3+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/vnd.lichess.v3+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Leaderboard.self,
                            from: responseBody,
                            transforming: { value in
                                .application_vnd_period_lichess_period_v3_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get user public data
    ///
    /// Read public data of a user.
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}`.
    /// - Remark: Generated from `#/paths//api/user/{username}/get(apiUser)`.
    internal func apiUser(_ input: Operations.apiUser.Input) async throws -> Operations.apiUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "trophies",
                    value: input.query.trophies
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUser.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserExtended.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get rating history of a user
    ///
    /// Read rating history of a user, for all perf types.
    /// There is at most one entry per day.
    /// Format of an entry is `[year, month, day, rating]`.
    /// `month` starts at zero (January).
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/rating-history`.
    /// - Remark: Generated from `#/paths//api/user/{username}/rating-history/get(apiUserRatingHistory)`.
    internal func apiUserRatingHistory(_ input: Operations.apiUserRatingHistory.Input) async throws -> Operations.apiUserRatingHistory.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserRatingHistory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/rating-history",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserRatingHistory.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserRatingHistory.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RatingHistory.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get performance statistics of a user
    ///
    /// Read performance statistics of a user, for a single performance.
    /// Similar to the [performance pages on the website](https://lichess.org/@/thibault/perf/bullet).
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/perf/{perf}`.
    /// - Remark: Generated from `#/paths//api/user/{username}/perf/{perf}/get(apiUserPerf)`.
    internal func apiUserPerf(_ input: Operations.apiUserPerf.Input) async throws -> Operations.apiUserPerf.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserPerf.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/perf/{}",
                    parameters: [
                        input.path.username,
                        input.path.perf
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserPerf.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserPerf.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PerfStat.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get user activity
    ///
    /// Read data to generate the activity feed of a user.
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/activity`.
    /// - Remark: Generated from `#/paths//api/user/{username}/activity/get(apiUserActivity)`.
    internal func apiUserActivity(_ input: Operations.apiUserActivity.Input) async throws -> Operations.apiUserActivity.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserActivity.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/activity",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserActivity.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserActivity.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.UserActivity].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the daily puzzle
    ///
    /// Get the daily Lichess puzzle in JSON format.
    /// Alternatively, you can [post it in your slack workspace](https://lichess.org/daily-puzzle-slack).
    ///
    ///
    /// - Remark: HTTP `GET /api/puzzle/daily`.
    /// - Remark: Generated from `#/paths//api/puzzle/daily/get(apiPuzzleDaily)`.
    internal func apiPuzzleDaily(_ input: Operations.apiPuzzleDaily.Input) async throws -> Operations.apiPuzzleDaily.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPuzzleDaily.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/puzzle/daily",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPuzzleDaily.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleDaily.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleAndGame.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a puzzle by its ID
    ///
    /// Get a single Lichess puzzle in JSON format.
    ///
    /// - Remark: HTTP `GET /api/puzzle/{id}`.
    /// - Remark: Generated from `#/paths//api/puzzle/{id}/get(apiPuzzleId)`.
    internal func apiPuzzleId(_ input: Operations.apiPuzzleId.Input) async throws -> Operations.apiPuzzleId.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPuzzleId.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/puzzle/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPuzzleId.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleId.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleAndGame.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a new puzzle
    ///
    /// Get a random Lichess puzzle in JSON format.
    ///
    /// If authenticated, only returns puzzles that the user has never seen before.
    ///
    /// **DO NOT** use this endpoint to enumerate puzzles for mass download. Instead, download the [full public puzzle database](https://database.lichess.org/#puzzles).
    ///
    ///
    /// - Remark: HTTP `GET /api/puzzle/next`.
    /// - Remark: Generated from `#/paths//api/puzzle/next/get(apiPuzzleNext)`.
    internal func apiPuzzleNext(_ input: Operations.apiPuzzleNext.Input) async throws -> Operations.apiPuzzleNext.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPuzzleNext.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/puzzle/next",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "angle",
                    value: input.query.angle
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "difficulty",
                    value: input.query.difficulty
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPuzzleNext.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleNext.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleAndGame.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get your puzzle activity
    ///
    /// Download your puzzle activity in [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
    /// Puzzle activity is sorted by reverse chronological order (most recent first)
    /// We recommend streaming the response, for it can be very long.
    ///
    ///
    /// - Remark: HTTP `GET /api/puzzle/activity`.
    /// - Remark: Generated from `#/paths//api/puzzle/activity/get(apiPuzzleActivity)`.
    internal func apiPuzzleActivity(_ input: Operations.apiPuzzleActivity.Input) async throws -> Operations.apiPuzzleActivity.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPuzzleActivity.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/puzzle/activity",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "max",
                    value: input.query.max
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before",
                    value: input.query.before
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPuzzleActivity.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleActivity.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get puzzles to replay
    ///
    /// Gets the puzzle IDs of remaining puzzles to re-attempt in JSON format.
    ///
    /// - Remark: HTTP `GET /api/puzzle/replay/{days}/{theme}`.
    /// - Remark: Generated from `#/paths//api/puzzle/replay/{days}/{theme}/get(apiPuzzleReplay)`.
    internal func apiPuzzleReplay(_ input: Operations.apiPuzzleReplay.Input) async throws -> Operations.apiPuzzleReplay.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPuzzleReplay.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/puzzle/replay/{}/{}",
                    parameters: [
                        input.path.days,
                        input.path.theme
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPuzzleReplay.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleReplay.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleReplay.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleReplay.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiPuzzleReplay.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get your puzzle dashboard
    ///
    /// Download your [puzzle dashboard](https://lichess.org/training/dashboard/30/dashboard) as JSON.
    /// Also includes all puzzle themes played, with aggregated results.
    /// Allows re-creating the [improvement/strengths](https://lichess.org/training/dashboard/30/improvementAreas) interfaces.
    ///
    ///
    /// - Remark: HTTP `GET /api/puzzle/dashboard/{days}`.
    /// - Remark: Generated from `#/paths//api/puzzle/dashboard/{days}/get(apiPuzzleDashboard)`.
    internal func apiPuzzleDashboard(_ input: Operations.apiPuzzleDashboard.Input) async throws -> Operations.apiPuzzleDashboard.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPuzzleDashboard.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/puzzle/dashboard/{}",
                    parameters: [
                        input.path.days
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPuzzleDashboard.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPuzzleDashboard.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleDashboard.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the storm dashboard of a player
    ///
    /// Download the [storm dashboard](https://lichess.org/storm/dashboard/mrbasso) of any player as JSON.
    /// Contains the aggregated highscores, and the history of storm runs aggregated by days.
    /// Use `?days=0` if you only care about the highscores.
    ///
    ///
    /// - Remark: HTTP `GET /api/storm/dashboard/{username}`.
    /// - Remark: Generated from `#/paths//api/storm/dashboard/{username}/get(apiStormDashboard)`.
    internal func apiStormDashboard(_ input: Operations.apiStormDashboard.Input) async throws -> Operations.apiStormDashboard.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiStormDashboard.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/storm/dashboard/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "days",
                    value: input.query.days
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiStormDashboard.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiStormDashboard.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleStormDashboard.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create and join a puzzle race
    ///
    /// Create a new private [puzzle race](https://lichess.org/racer).
    /// The Lichess user who creates the race must join the race page,
    /// and manually start the race when enough players have joined.
    /// - <https://lichess.org/racer>
    ///
    ///
    /// - Remark: HTTP `POST /api/racer`.
    /// - Remark: Generated from `#/paths//api/racer/post(racerPost)`.
    internal func racerPost(_ input: Operations.racerPost.Input) async throws -> Operations.racerPost.Output {
        try await client.send(
            input: input,
            forOperation: Operations.racerPost.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/racer",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.racerPost.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.racerPost.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleRacer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get puzzle race results
    ///
    /// Get the results of a [puzzle race](https://lichess.org/racer).
    /// Returns information about players, puzzles, and the current status of the race.
    /// - <https://lichess.org/racer>
    ///
    /// Note that Lichess puzzle races are not persisted, and are only available
    /// for 30 minutes. After that delay, they are permanently deleted.
    ///
    ///
    /// - Remark: HTTP `GET /api/racer/{id}`.
    /// - Remark: Generated from `#/paths//api/racer/{id}/get(racerGet)`.
    internal func racerGet(_ input: Operations.racerGet.Input) async throws -> Operations.racerGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.racerGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/racer/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.racerGet.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.racerGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PuzzleRaceResults.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.racerGet.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get users by ID
    ///
    /// Get up to 300 users by their IDs. Users are returned in the same order as the IDs.
    /// The method is `POST` to allow a longer list of IDs to be sent in the request body.
    /// Please do not try to download all the Lichess users with this endpoint, or any other endpoint.
    /// An API is not a way to fully export a website. We do not provide a full download of the Lichess users.
    /// This endpoint is limited to 8,000 users every 10 minutes, and 120,000 every day.
    ///
    ///
    /// - Remark: HTTP `POST /api/users`.
    /// - Remark: Generated from `#/paths//api/users/post(apiUsers)`.
    internal func apiUsers(_ input: Operations.apiUsers.Input) async throws -> Operations.apiUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUsers.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUsers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.User].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get my profile
    ///
    /// Public information about the logged in user.
    ///
    ///
    /// - Remark: HTTP `GET /api/account`.
    /// - Remark: Generated from `#/paths//api/account/get(accountMe)`.
    internal func accountMe(_ input: Operations.accountMe.Input) async throws -> Operations.accountMe.Output {
        try await client.send(
            input: input,
            forOperation: Operations.accountMe.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/account",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.accountMe.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.accountMe.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserExtended.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get my email address
    ///
    /// Read the email address of the logged in user.
    ///
    ///
    /// - Remark: HTTP `GET /api/account/email`.
    /// - Remark: Generated from `#/paths//api/account/email/get(accountEmail)`.
    internal func accountEmail(_ input: Operations.accountEmail.Input) async throws -> Operations.accountEmail.Output {
        try await client.send(
            input: input,
            forOperation: Operations.accountEmail.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/account/email",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.accountEmail.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.accountEmail.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.accountEmail.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get my preferences
    ///
    /// Read the preferences of the logged in user.
    /// - <https://lichess.org/account/preferences/game-display>
    /// - <https://github.com/ornicar/lila/blob/master/modules/pref/src/main/Pref.scala>
    ///
    ///
    /// - Remark: HTTP `GET /api/account/preferences`.
    /// - Remark: Generated from `#/paths//api/account/preferences/get(account)`.
    internal func account(_ input: Operations.account.Input) async throws -> Operations.account.Output {
        try await client.send(
            input: input,
            forOperation: Operations.account.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/account/preferences",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.account.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.account.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.account.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get my kid mode status
    ///
    /// Read the kid mode status of the logged in user.
    /// - <https://lichess.org/account/kid>
    ///
    ///
    /// - Remark: HTTP `GET /api/account/kid`.
    /// - Remark: Generated from `#/paths//api/account/kid/get(accountKid)`.
    internal func accountKid(_ input: Operations.accountKid.Input) async throws -> Operations.accountKid.Output {
        try await client.send(
            input: input,
            forOperation: Operations.accountKid.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/account/kid",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.accountKid.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.accountKid.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.accountKid.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Set my kid mode status
    ///
    /// Set the kid mode status of the logged in user.
    /// - <https://lichess.org/account/kid>
    ///
    ///
    /// - Remark: HTTP `POST /api/account/kid`.
    /// - Remark: Generated from `#/paths//api/account/kid/post(accountKidPost)`.
    internal func accountKidPost(_ input: Operations.accountKidPost.Input) async throws -> Operations.accountKidPost.Output {
        try await client.send(
            input: input,
            forOperation: Operations.accountKidPost.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/account/kid",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "v",
                    value: input.query.v
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.accountKidPost.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.accountKidPost.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get my timeline
    ///
    /// Get the timeline events of the logged in user.
    ///
    ///
    /// - Remark: HTTP `GET /api/timeline`.
    /// - Remark: Generated from `#/paths//api/timeline/get(timeline)`.
    internal func timeline(_ input: Operations.timeline.Input) async throws -> Operations.timeline.Output {
        try await client.send(
            input: input,
            forOperation: Operations.timeline.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/timeline",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.timeline.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.timeline.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Timeline.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export one game
    ///
    /// Download one game in either PGN or JSON format.
    /// Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
    ///
    ///
    /// - Remark: HTTP `GET /game/export/{gameId}`.
    /// - Remark: Generated from `#/paths//game/export/{gameId}/get(gamePgn)`.
    internal func gamePgn(_ input: Operations.gamePgn.Input) async throws -> Operations.gamePgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamePgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/game/export/{}",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "literate",
                    value: input.query.literate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "withBookmarked",
                    value: input.query.withBookmarked
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamePgn.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamePgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GameJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export ongoing game of a user
    ///
    /// Download the ongoing game, or the last game played, of a user.
    /// Available in either PGN or JSON format.
    /// Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/current-game`.
    /// - Remark: Generated from `#/paths//api/user/{username}/current-game/get(apiUserCurrentGame)`.
    internal func apiUserCurrentGame(_ input: Operations.apiUserCurrentGame.Input) async throws -> Operations.apiUserCurrentGame.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserCurrentGame.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/current-game",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "literate",
                    value: input.query.literate
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserCurrentGame.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserCurrentGame.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GameJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export games of a user
    ///
    /// Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
    /// Games are sorted by reverse chronological order (most recent first).
    /// We recommend streaming the response, for it can be very long.
    /// <https://lichess.org/@/german11> for instance has more than 500,000 games.
    /// The game stream is throttled, depending on who is making the request:
    ///   - Anonymous request: 20 games per second
    ///   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
    ///   - Authenticated, downloading your own games: 60 games per second
    ///
    ///
    /// - Remark: HTTP `GET /api/games/user/{username}`.
    /// - Remark: Generated from `#/paths//api/games/user/{username}/get(apiGamesUser)`.
    internal func apiGamesUser(_ input: Operations.apiGamesUser.Input) async throws -> Operations.apiGamesUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiGamesUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/games/user/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "max",
                    value: input.query.max
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "vs",
                    value: input.query.vs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "rated",
                    value: input.query.rated
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perfType",
                    value: input.query.perfType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "color",
                    value: input.query.color
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "analysed",
                    value: input.query.analysed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ongoing",
                    value: input.query.ongoing
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "finished",
                    value: input.query.finished
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "literate",
                    value: input.query.literate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lastFen",
                    value: input.query.lastFen
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "withBookmarked",
                    value: input.query.withBookmarked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiGamesUser.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiGamesUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export games by IDs
    ///
    /// Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
    /// Games are sorted by reverse chronological order (most recent first)
    /// The method is `POST` so a longer list of IDs can be sent in the request body.
    /// 300 IDs can be submitted.
    /// Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
    ///
    ///
    /// - Remark: HTTP `POST /api/games/export/_ids`.
    /// - Remark: Generated from `#/paths//api/games/export/_ids/post(gamesExportIds)`.
    internal func gamesExportIds(_ input: Operations.gamesExportIds.Input) async throws -> Operations.gamesExportIds.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamesExportIds.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/games/export/_ids",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "literate",
                    value: input.query.literate
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamesExportIds.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamesExportIds.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream games of users
    ///
    /// Stream the games played between a list of users, in real time.
    /// Only games where **both players** are part of the list are included.
    /// The stream emits an event each time a game is started or finished.
    /// To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.
    /// Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// Maximum number of users: 300.
    /// The method is `POST` so a longer list of IDs can be sent in the request body.
    ///
    ///
    /// - Remark: HTTP `POST /api/stream/games-by-users`.
    /// - Remark: Generated from `#/paths//api/stream/games-by-users/post(gamesByUsers)`.
    internal func gamesByUsers(_ input: Operations.gamesByUsers.Input) async throws -> Operations.gamesByUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamesByUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/stream/games-by-users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "withCurrentGames",
                    value: input.query.withCurrentGames
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamesByUsers.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamesByUsers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream games by IDs
    ///
    /// Creates a stream of games from an arbitrary streamId, and a list of game IDs.
    /// The stream first outputs the games that already exists, then emits an event each time a game is started or finished.
    /// Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Introduction/Authentication) requests.
    /// While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd).
    ///
    ///
    /// - Remark: HTTP `POST /api/stream/games/{streamId}`.
    /// - Remark: Generated from `#/paths//api/stream/games/{streamId}/post(gamesByIds)`.
    internal func gamesByIds(_ input: Operations.gamesByIds.Input) async throws -> Operations.gamesByIds.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamesByIds.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/stream/games/{}",
                    parameters: [
                        input.path.streamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamesByIds.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamesByIds.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add game IDs to stream
    ///
    /// Add new game IDs for [an existing stream](#operation/gamesByIds) to watch.
    /// The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished.
    ///
    ///
    /// - Remark: HTTP `POST /api/stream/games/{streamId}/add`.
    /// - Remark: Generated from `#/paths//api/stream/games/{streamId}/add/post(gamesByIdsAdd)`.
    internal func gamesByIdsAdd(_ input: Operations.gamesByIdsAdd.Input) async throws -> Operations.gamesByIdsAdd.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamesByIdsAdd.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/stream/games/{}/add",
                    parameters: [
                        input.path.streamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamesByIdsAdd.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamesByIdsAdd.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get my ongoing games
    ///
    /// Get the ongoing games of the current user.
    /// Real-time and correspondence games are included.
    /// The most urgent games are listed first.
    ///
    ///
    /// - Remark: HTTP `GET /api/account/playing`.
    /// - Remark: Generated from `#/paths//api/account/playing/get(apiAccountPlaying)`.
    internal func apiAccountPlaying(_ input: Operations.apiAccountPlaying.Input) async throws -> Operations.apiAccountPlaying.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiAccountPlaying.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/account/playing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiAccountPlaying.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiAccountPlaying.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiAccountPlaying.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream moves of a game
    ///
    /// Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// A description of the game is sent as a first message.
    /// Then a message is sent each time a move is played.
    /// Finally, a description of the game is sent when it finishes, and the stream is closed.
    /// Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
    /// No more than 8 game streams can be opened at the same time from the same IP address.
    ///
    ///
    /// - Remark: HTTP `GET /api/stream/game/{id}`.
    /// - Remark: Generated from `#/paths//api/stream/game/{id}/get(streamGame)`.
    internal func streamGame(_ input: Operations.streamGame.Input) async throws -> Operations.streamGame.Output {
        try await client.send(
            input: input,
            forOperation: Operations.streamGame.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/stream/game/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.streamGame.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 429:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.streamGame.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.streamGame.Output.TooManyRequests.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Import one game
    ///
    /// Import a game from PGN. See <https://lichess.org/paste>.
    /// Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.
    /// To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).
    /// To analyse a position or a line, just construct an analysis board URL (most standard tags supported if URL-encoded):
    /// [https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+](https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+)
    ///
    ///
    /// - Remark: HTTP `POST /api/import`.
    /// - Remark: Generated from `#/paths//api/import/post(gameImport)`.
    internal func gameImport(_ input: Operations.gameImport.Input) async throws -> Operations.gameImport.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gameImport.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/import",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gameImport.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gameImport.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.gameImport.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export your imported games
    ///
    /// Download all games imported by you. Games are exported in PGN format.
    ///
    /// - Remark: HTTP `GET /api/games/export/imports`.
    /// - Remark: Generated from `#/paths//api/games/export/imports/get(apiImportedGamesUser)`.
    internal func apiImportedGamesUser(_ input: Operations.apiImportedGamesUser.Input) async throws -> Operations.apiImportedGamesUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiImportedGamesUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/games/export/imports",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiImportedGamesUser.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiImportedGamesUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export your bookmarked games
    ///
    /// Download all games bookmarked by you, in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
    /// Games are sorted by reverse chronological order (most recent first).
    /// We recommend streaming the response, for it can be very long.
    ///
    ///
    /// - Remark: HTTP `GET /api/games/export/bookmarks`.
    /// - Remark: Generated from `#/paths//api/games/export/bookmarks/get(apiExportBookmarks)`.
    internal func apiExportBookmarks(_ input: Operations.apiExportBookmarks.Input) async throws -> Operations.apiExportBookmarks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExportBookmarks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/games/export/bookmarks",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "max",
                    value: input.query.max
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "literate",
                    value: input.query.literate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lastFen",
                    value: input.query.lastFen
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExportBookmarks.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExportBookmarks.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get current TV games
    ///
    /// Get basic info about the best games being played for each speed and variant,
    /// but also computer games and bot games.
    /// See [lichess.org/tv](https://lichess.org/tv).
    ///
    ///
    /// - Remark: HTTP `GET /api/tv/channels`.
    /// - Remark: Generated from `#/paths//api/tv/channels/get(tvChannels)`.
    internal func tvChannels(_ input: Operations.tvChannels.Input) async throws -> Operations.tvChannels.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tvChannels.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tv/channels",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.tvChannels.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tvChannels.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.tvChannels.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream current TV game
    ///
    /// Stream positions and moves of the current [TV game](https://lichess.org/tv) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// Try it with `curl https://lichess.org/api/tv/feed`.
    ///
    ///
    /// - Remark: HTTP `GET /api/tv/feed`.
    /// - Remark: Generated from `#/paths//api/tv/feed/get(tvFeed)`.
    internal func tvFeed(_ input: Operations.tvFeed.Input) async throws -> Operations.tvFeed.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tvFeed.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tv/feed",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tvFeed.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream current TV game of a TV channel
    ///
    /// Stream positions and moves of a current [TV channel's game](https://lichess.org/tv/rapid) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// Try it with `curl https://lichess.org/api/tv/rapid/feed`.
    ///
    ///
    /// - Remark: HTTP `GET /api/tv/{channel}/feed`.
    /// - Remark: Generated from `#/paths//api/tv/{channel}/feed/get(tvChannelFeed)`.
    internal func tvChannelFeed(_ input: Operations.tvChannelFeed.Input) async throws -> Operations.tvChannelFeed.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tvChannelFeed.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tv/{}/feed",
                    parameters: [
                        input.path.channel
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tvChannelFeed.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get best ongoing games of a TV channel
    ///
    /// Get a list of ongoing games for a given TV channel. Similar to [lichess.org/games](https://lichess.org/games).
    /// Available in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
    ///
    ///
    /// - Remark: HTTP `GET /api/tv/{channel}`.
    /// - Remark: Generated from `#/paths//api/tv/{channel}/get(tvChannelGames)`.
    internal func tvChannelGames(_ input: Operations.tvChannelGames.Input) async throws -> Operations.tvChannelGames.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tvChannelGames.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tv/{}",
                    parameters: [
                        input.path.channel
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tvChannelGames.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get current tournaments
    ///
    /// Get recently active and finished tournaments.
    /// This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament).
    ///
    ///
    /// - Remark: HTTP `GET /api/tournament`.
    /// - Remark: Generated from `#/paths//api/tournament/get(apiTournament)`.
    internal func apiTournament(_ input: Operations.apiTournament.Input) async throws -> Operations.apiTournament.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournament.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournament.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournament.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ArenaTournaments.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a new Arena tournament
    ///
    /// Create a public or private Arena tournament.
    /// This endpoint mirrors the form on <https://lichess.org/tournament/new>.
    /// You can create up to 12 public tournaments per day, or 24 private tournaments.
    /// A team battle can be created by specifying the `teamBattleByTeam` argument.
    /// Additional restrictions:
    ///   - clockTime + clockIncrement > 0
    ///   - 15s and 0+1 variant tournaments cannot be rated
    ///   - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
    ///
    ///
    /// - Remark: HTTP `POST /api/tournament`.
    /// - Remark: Generated from `#/paths//api/tournament/post(apiTournamentPost)`.
    internal func apiTournamentPost(_ input: Operations.apiTournamentPost.Input) async throws -> Operations.apiTournamentPost.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournamentPost.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournamentPost.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentPost.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ArenaTournamentFull.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentPost.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get info about an Arena tournament
    ///
    /// Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info.
    ///
    ///
    /// - Remark: HTTP `GET /api/tournament/{id}`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/get(tournament)`.
    internal func tournament(_ input: Operations.tournament.Input) async throws -> Operations.tournament.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tournament.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.tournament.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tournament.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ArenaTournamentFull.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update an Arena tournament
    ///
    /// Update an Arena tournament.
    /// Be mindful not to make important changes to ongoing tournaments.
    /// Can be used to update a team battle.
    /// Additional restrictions:
    ///   - clockTime + clockIncrement > 0
    ///   - 15s and 0+1 variant tournaments cannot be rated
    ///   - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
    ///
    ///
    /// - Remark: HTTP `POST /api/tournament/{id}`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/post(apiTournamentUpdate)`.
    internal func apiTournamentUpdate(_ input: Operations.apiTournamentUpdate.Input) async throws -> Operations.apiTournamentUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournamentUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournamentUpdate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentUpdate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ArenaTournamentFull.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentUpdate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Join an Arena tournament
    ///
    /// Join an Arena tournament, possibly with a password and/or a team.
    /// Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament.
    ///
    ///
    /// - Remark: HTTP `POST /api/tournament/{id}/join`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/join/post(apiTournamentJoin)`.
    internal func apiTournamentJoin(_ input: Operations.apiTournamentJoin.Input) async throws -> Operations.apiTournamentJoin.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournamentJoin.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}/join",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournamentJoin.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentJoin.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentJoin.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Pause or leave an Arena tournament
    ///
    /// Leave a future Arena tournament, or take a break on an ongoing Arena tournament.
    /// It's possible to join again later. Points and streaks are preserved.
    ///
    ///
    /// - Remark: HTTP `POST /api/tournament/{id}/withdraw`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/withdraw/post(apiTournamentWithdraw)`.
    internal func apiTournamentWithdraw(_ input: Operations.apiTournamentWithdraw.Input) async throws -> Operations.apiTournamentWithdraw.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournamentWithdraw.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}/withdraw",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournamentWithdraw.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentWithdraw.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentWithdraw.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Terminate an Arena tournament
    ///
    /// Terminate an Arena tournament
    ///
    ///
    /// - Remark: HTTP `POST /api/tournament/{id}/terminate`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/terminate/post(apiTournamentTerminate)`.
    internal func apiTournamentTerminate(_ input: Operations.apiTournamentTerminate.Input) async throws -> Operations.apiTournamentTerminate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournamentTerminate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}/terminate",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournamentTerminate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentTerminate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentTerminate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update a team battle
    ///
    /// Set the teams and number of leaders of a team battle.
    /// To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate).
    ///
    ///
    /// - Remark: HTTP `POST /api/tournament/team-battle/{id}`.
    /// - Remark: Generated from `#/paths//api/tournament/team-battle/{id}/post(apiTournamentTeamBattlePost)`.
    internal func apiTournamentTeamBattlePost(_ input: Operations.apiTournamentTeamBattlePost.Input) async throws -> Operations.apiTournamentTeamBattlePost.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTournamentTeamBattlePost.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/team-battle/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTournamentTeamBattlePost.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentTeamBattlePost.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ArenaTournamentFull.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTournamentTeamBattlePost.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export games of an Arena tournament
    ///
    /// Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
    /// Games are sorted by reverse chronological order (most recent first).
    /// The game stream is throttled, depending on who is making the request:
    ///   - Anonymous request: 20 games per second
    ///   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
    ///
    ///
    /// - Remark: HTTP `GET /api/tournament/{id}/games`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/games/get(gamesByTournament)`.
    internal func gamesByTournament(_ input: Operations.gamesByTournament.Input) async throws -> Operations.gamesByTournament.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamesByTournament.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}/games",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "player",
                    value: input.query.player
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamesByTournament.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamesByTournament.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get results of an Arena tournament
    ///
    /// Players of an Arena tournament, with their score and performance, sorted by rank (best first).
    /// **Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.
    /// If called on an ongoing tournament, results can be inconsistent
    /// due to ranking changes while the players are being streamed.
    /// Use on finished tournaments for guaranteed consistency.
    ///
    ///
    /// - Remark: HTTP `GET /api/tournament/{id}/results`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/results/get(resultsByTournament)`.
    internal func resultsByTournament(_ input: Operations.resultsByTournament.Input) async throws -> Operations.resultsByTournament.Output {
        try await client.send(
            input: input,
            forOperation: Operations.resultsByTournament.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}/results",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sheet",
                    value: input.query.sheet
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.resultsByTournament.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.resultsByTournament.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get team standing of a team battle
    ///
    /// Teams of a team battle tournament, with top players, sorted by rank (best first).
    ///
    ///
    /// - Remark: HTTP `GET /api/tournament/{id}/teams`.
    /// - Remark: Generated from `#/paths//api/tournament/{id}/teams/get(teamsByTournament)`.
    internal func teamsByTournament(_ input: Operations.teamsByTournament.Input) async throws -> Operations.teamsByTournament.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamsByTournament.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/tournament/{}/teams",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamsByTournament.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamsByTournament.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.teamsByTournament.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get tournaments created by a user
    ///
    /// Get all tournaments created by a given user.
    /// Tournaments are sorted by reverse chronological order of start date (last starting first).
    /// Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// The stream is throttled, depending on who is making the request:
    ///   - Anonymous request: 20 tournaments per second
    ///   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
    ///   - Authenticated, downloading your own tournaments: 50 tournaments per second
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/tournament/created`.
    /// - Remark: Generated from `#/paths//api/user/{username}/tournament/created/get(apiUserNameTournamentCreated)`.
    internal func apiUserNameTournamentCreated(_ input: Operations.apiUserNameTournamentCreated.Input) async throws -> Operations.apiUserNameTournamentCreated.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserNameTournamentCreated.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/tournament/created",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserNameTournamentCreated.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserNameTournamentCreated.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get tournaments played by a user
    ///
    /// Get all tournaments played by a given user.
    /// Tournaments are sorted by reverse chronological order of start date (last played first).
    /// Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// The stream is throttled, depending on who is making the request:
    ///   - Anonymous request: 20 tournaments per second
    ///   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
    ///   - Authenticated, downloading your own tournaments: 50 tournaments per second
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/tournament/played`.
    /// - Remark: Generated from `#/paths//api/user/{username}/tournament/played/get(apiUserNameTournamentPlayed)`.
    internal func apiUserNameTournamentPlayed(_ input: Operations.apiUserNameTournamentPlayed.Input) async throws -> Operations.apiUserNameTournamentPlayed.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserNameTournamentPlayed.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/tournament/played",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "performance",
                    value: input.query.performance
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserNameTournamentPlayed.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserNameTournamentPlayed.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a new Swiss tournament
    ///
    /// Create a Swiss tournament for your team.
    /// This endpoint mirrors the Swiss tournament form from your team pagee.
    /// You can create up to 12 tournaments per day.
    /// Additional restrictions:
    ///   - clock.limit + clock.increment > 0
    ///   - 15s and 0+1 variant tournaments cannot be rated
    ///
    ///
    /// - Remark: HTTP `POST /api/swiss/new/{teamId}`.
    /// - Remark: Generated from `#/paths//api/swiss/new/{teamId}/post(apiSwissNew)`.
    internal func apiSwissNew(_ input: Operations.apiSwissNew.Input) async throws -> Operations.apiSwissNew.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSwissNew.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/new/{}",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiSwissNew.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissNew.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SwissTournament.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissNew.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get info about a Swiss tournament
    ///
    /// Get detailed info about a Swiss tournament.
    ///
    ///
    /// - Remark: HTTP `GET /api/swiss/{id}`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/get(swiss)`.
    internal func swiss(_ input: Operations.swiss.Input) async throws -> Operations.swiss.Output {
        try await client.send(
            input: input,
            forOperation: Operations.swiss.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.swiss.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.swiss.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SwissTournament.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update a Swiss tournament
    ///
    /// Update a Swiss tournament.
    /// Be mindful not to make important changes to ongoing tournaments.
    /// Additional restrictions:
    ///   - clock.limit + clock.increment > 0
    ///   - 15s and 0+1 variant tournaments cannot be rated
    ///
    ///
    /// - Remark: HTTP `POST /api/swiss/{id}/edit`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/edit/post(apiSwissUpdate)`.
    internal func apiSwissUpdate(_ input: Operations.apiSwissUpdate.Input) async throws -> Operations.apiSwissUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSwissUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/edit",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiSwissUpdate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissUpdate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SwissTournament.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissUpdate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissUpdate.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SwissUnauthorisedEdit.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Manually schedule the next round
    ///
    /// Manually schedule the next round date and time of a Swiss tournament.
    /// This sets the `roundInterval` field to `99999999`, i.e. manual scheduling.
    /// All further rounds will need to be manually scheduled, unless the `roundInterval` field is changed back to automatic scheduling.
    ///
    ///
    /// - Remark: HTTP `POST /api/swiss/{id}/schedule-next-round`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/schedule-next-round/post(apiSwissScheduleNextRound)`.
    internal func apiSwissScheduleNextRound(_ input: Operations.apiSwissScheduleNextRound.Input) async throws -> Operations.apiSwissScheduleNextRound.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSwissScheduleNextRound.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/schedule-next-round",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    let headers: Operations.apiSwissScheduleNextRound.Output.NoContent.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    return .noContent(.init(headers: headers))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissScheduleNextRound.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissScheduleNextRound.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SwissUnauthorisedEdit.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Join a Swiss tournament
    ///
    /// Join a Swiss tournament, possibly with a password.
    ///
    ///
    /// - Remark: HTTP `POST /api/swiss/{id}/join`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/join/post(apiSwissJoin)`.
    internal func apiSwissJoin(_ input: Operations.apiSwissJoin.Input) async throws -> Operations.apiSwissJoin.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSwissJoin.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/join",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiSwissJoin.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissJoin.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissJoin.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Pause or leave a swiss tournament
    ///
    /// Leave a future Swiss tournament, or take a break on an ongoing Swiss tournament.
    /// It's possible to join again later. Points are preserved.
    ///
    ///
    /// - Remark: HTTP `POST /api/swiss/{id}/withdraw`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/withdraw/post(apiSwissWithdraw)`.
    internal func apiSwissWithdraw(_ input: Operations.apiSwissWithdraw.Input) async throws -> Operations.apiSwissWithdraw.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSwissWithdraw.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/withdraw",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiSwissWithdraw.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissWithdraw.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Terminate a Swiss tournament
    ///
    /// Terminate a Swiss tournament
    ///
    ///
    /// - Remark: HTTP `POST /api/swiss/{id}/terminate`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/terminate/post(apiSwissTerminate)`.
    internal func apiSwissTerminate(_ input: Operations.apiSwissTerminate.Input) async throws -> Operations.apiSwissTerminate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSwissTerminate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/terminate",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiSwissTerminate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissTerminate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSwissTerminate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export TRF of a Swiss tournament
    ///
    /// Download a tournament in the Tournament Report File format, the FIDE standard.
    /// Documentation: <https://www.fide.com/FIDE/handbook/C04Annex2_TRF16.pdf>
    /// Example: <https://lichess.org/swiss/j8rtJ5GL.trf>
    ///
    ///
    /// - Remark: HTTP `GET /swiss/{id}.trf`.
    /// - Remark: Generated from `#/paths//swiss/{id}.trf/get(swissTrf)`.
    internal func swissTrf(_ input: Operations.swissTrf.Input) async throws -> Operations.swissTrf.Output {
        try await client.send(
            input: input,
            forOperation: Operations.swissTrf.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/swiss/{}.trf",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.swissTrf.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.swissTrf.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/plain"
                        ]
                    )
                    switch chosenContentType {
                    case "text/plain":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .plainText(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export games of a Swiss tournament
    ///
    /// Download games of a swiss tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
    /// Games are sorted by chronological order.
    /// The game stream is throttled, depending on who is making the request:
    ///   - Anonymous request: 20 games per second
    ///   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
    ///
    ///
    /// - Remark: HTTP `GET /api/swiss/{id}/games`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/games/get(gamesBySwiss)`.
    internal func gamesBySwiss(_ input: Operations.gamesBySwiss.Input) async throws -> Operations.gamesBySwiss.Output {
        try await client.send(
            input: input,
            forOperation: Operations.gamesBySwiss.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/games",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "player",
                    value: input.query.player
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.gamesBySwiss.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.gamesBySwiss.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get results of a swiss tournament
    ///
    /// Players of a swiss tournament, with their score and performance, sorted by rank (best first).
    /// Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// If called on an ongoing tournament, results can be inconsistent
    /// due to ranking changes while the players are being streamed.
    /// Use on finished tournaments for guaranteed consistency.
    ///
    ///
    /// - Remark: HTTP `GET /api/swiss/{id}/results`.
    /// - Remark: Generated from `#/paths//api/swiss/{id}/results/get(resultsBySwiss)`.
    internal func resultsBySwiss(_ input: Operations.resultsBySwiss.Input) async throws -> Operations.resultsBySwiss.Output {
        try await client.send(
            input: input,
            forOperation: Operations.resultsBySwiss.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/swiss/{}/results",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.resultsBySwiss.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.resultsBySwiss.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get team swiss tournaments
    ///
    /// Get all swiss tournaments of a team.
    /// Tournaments are sorted by reverse chronological order of start date (last starting first).
    /// Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    ///
    /// - Remark: HTTP `GET /api/team/{teamId}/swiss`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/swiss/get(apiTeamSwiss)`.
    internal func apiTeamSwiss(_ input: Operations.apiTeamSwiss.Input) async throws -> Operations.apiTeamSwiss.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTeamSwiss.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/swiss",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "max",
                    value: input.query.max
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdBy",
                    value: input.query.createdBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTeamSwiss.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTeamSwiss.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export one study chapter
    ///
    /// Download one study chapter in PGN format.
    ///
    ///
    /// - Remark: HTTP `GET /api/study/{studyId}/{chapterId}.pgn`.
    /// - Remark: Generated from `#/paths//api/study/{studyId}/{chapterId}.pgn/get(studyChapterPgn)`.
    internal func studyChapterPgn(_ input: Operations.studyChapterPgn.Input) async throws -> Operations.studyChapterPgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.studyChapterPgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/study/{}/{}.pgn",
                    parameters: [
                        input.path.studyId,
                        input.path.chapterId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "comments",
                    value: input.query.comments
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "variations",
                    value: input.query.variations
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orientation",
                    value: input.query.orientation
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.studyChapterPgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export all chapters
    ///
    /// Download all chapters of a study in PGN format.
    ///
    ///
    /// - Remark: HTTP `GET /api/study/{studyId}.pgn`.
    /// - Remark: Generated from `#/paths//api/study/{studyId}.pgn/get(studyAllChaptersPgn)`.
    internal func studyAllChaptersPgn(_ input: Operations.studyAllChaptersPgn.Input) async throws -> Operations.studyAllChaptersPgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.studyAllChaptersPgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/study/{}.pgn",
                    parameters: [
                        input.path.studyId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "comments",
                    value: input.query.comments
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "variations",
                    value: input.query.variations
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orientation",
                    value: input.query.orientation
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.studyAllChaptersPgn.Output.Ok.Headers = .init(
                        Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Access-Control-Allow-Origin",
                            as: Swift.String.self
                        ),
                        Last_hyphen_Modified: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Last-Modified",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.studyAllChaptersPgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Study metadata
    ///
    /// Only get the study headers, including `Last-Modified`.
    ///
    ///
    /// - Remark: HTTP `HEAD /api/study/{studyId}.pgn`.
    /// - Remark: Generated from `#/paths//api/study/{studyId}.pgn/head(studyAllChaptersHead)`.
    internal func studyAllChaptersHead(_ input: Operations.studyAllChaptersHead.Input) async throws -> Operations.studyAllChaptersHead.Output {
        try await client.send(
            input: input,
            forOperation: Operations.studyAllChaptersHead.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/study/{}.pgn",
                    parameters: [
                        input.path.studyId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    let headers: Operations.studyAllChaptersHead.Output.NoContent.Headers = .init(
                        Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Access-Control-Allow-Origin",
                            as: Swift.String.self
                        ),
                        Last_hyphen_Modified: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Last-Modified",
                            as: Swift.String.self
                        )
                    )
                    return .noContent(.init(headers: headers))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Import PGN into a study
    ///
    /// Imports arbitrary PGN into an existing [study](https://lichess.org/study). Creates a new chapter in the study.
    /// If the PGN contains multiple games (separated by 2 or more newlines)
    /// then multiple chapters will be created within the study.
    /// Note that a study can contain at most 64 chapters.
    ///
    ///
    /// - Remark: HTTP `POST /api/study/{studyId}/import-pgn`.
    /// - Remark: Generated from `#/paths//api/study/{studyId}/import-pgn/post(apiStudyImportPGN)`.
    internal func apiStudyImportPGN(_ input: Operations.apiStudyImportPGN.Input) async throws -> Operations.apiStudyImportPGN.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiStudyImportPGN.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/study/{}/import-pgn",
                    parameters: [
                        input.path.studyId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiStudyImportPGN.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiStudyImportPGN.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.StudyImportPgnChapters.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiStudyImportPGN.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export all studies of a user
    ///
    /// Download all chapters of all studies of a user in PGN format.
    /// If authenticated, then all public, unlisted, and private studies are included.
    /// If not, only public (non-unlisted) studies are included.
    ///
    ///
    /// - Remark: HTTP `GET /study/by/{username}/export.pgn`.
    /// - Remark: Generated from `#/paths//study/by/{username}/export.pgn/get(studyExportAllPgn)`.
    internal func studyExportAllPgn(_ input: Operations.studyExportAllPgn.Input) async throws -> Operations.studyExportAllPgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.studyExportAllPgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/study/by/{}/export.pgn",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "comments",
                    value: input.query.comments
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "variations",
                    value: input.query.variations
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orientation",
                    value: input.query.orientation
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.studyExportAllPgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List studies of a user
    ///
    /// Get metadata (name and dates) of all studies of a user.
    /// If authenticated, then all public, unlisted, and private studies are included.
    /// If not, only public (non-unlisted) studies are included.
    /// Studies are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    ///
    /// - Remark: HTTP `GET /api/study/by/{username}`.
    /// - Remark: Generated from `#/paths//api/study/by/{username}/get(studyListMetadata)`.
    internal func studyListMetadata(_ input: Operations.studyListMetadata.Input) async throws -> Operations.studyListMetadata.Output {
        try await client.send(
            input: input,
            forOperation: Operations.studyListMetadata.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/study/by/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.studyListMetadata.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.studyListMetadata.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a study chapter
    ///
    /// Delete a chapter of a study you own. This is definitive.
    /// A study must have at least one chapter; so if you delete the last chapter,
    /// an empty one will be automatically created to replace it.
    ///
    ///
    /// - Remark: HTTP `DELETE /api/study/{studyId}/{chapterId}`.
    /// - Remark: Generated from `#/paths//api/study/{studyId}/{chapterId}/delete(apiStudyStudyIdChapterIdDelete)`.
    internal func apiStudyStudyIdChapterIdDelete(_ input: Operations.apiStudyStudyIdChapterIdDelete.Input) async throws -> Operations.apiStudyStudyIdChapterIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiStudyStudyIdChapterIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/study/{}/{}",
                    parameters: [
                        input.path.studyId,
                        input.path.chapterId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    let headers: Operations.apiStudyStudyIdChapterIdDelete.Output.NoContent.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    return .noContent(.init(headers: headers))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get official broadcasts
    ///
    /// Returns ongoing official broadcasts sorted by tier. 
    /// After that, returns finished broadcasts sorted by most recent sync time.
    /// Broadcasts are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast`.
    /// - Remark: Generated from `#/paths//api/broadcast/get(broadcastsOfficial)`.
    internal func broadcastsOfficial(_ input: Operations.broadcastsOfficial.Input) async throws -> Operations.broadcastsOfficial.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastsOfficial.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "html",
                    value: input.query.html
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastsOfficial.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastsOfficial.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get paginated top broadcast previews
    ///
    /// The same data, in the same order, as can be seen on [https://lichess.org/broadcast](/broadcast).
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/top`.
    /// - Remark: Generated from `#/paths//api/broadcast/top/get(broadcastsTop)`.
    internal func broadcastsTop(_ input: Operations.broadcastsTop.Input) async throws -> Operations.broadcastsTop.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastsTop.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/top",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "html",
                    value: input.query.html
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastsTop.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastsTop.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastTop.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get broadcasts created by a user
    ///
    /// Get all incoming, ongoing, and finished official broadcasts.
    /// The broadcasts are sorted by created date, most recent first.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/by/{username}`.
    /// - Remark: Generated from `#/paths//api/broadcast/by/{username}/get(broadcastsByUser)`.
    internal func broadcastsByUser(_ input: Operations.broadcastsByUser.Input) async throws -> Operations.broadcastsByUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastsByUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/by/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "html",
                    value: input.query.html
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastsByUser.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastsByUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.broadcastsByUser.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search broadcasts
    ///
    /// Search across recent official broadcasts.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/search`.
    /// - Remark: Generated from `#/paths//api/broadcast/search/get(broadcastsSearch)`.
    internal func broadcastsSearch(_ input: Operations.broadcastsSearch.Input) async throws -> Operations.broadcastsSearch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastsSearch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "q",
                    value: input.query.q
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastsSearch.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastsSearch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.broadcastsSearch.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a broadcast tournament
    ///
    /// Create a new broadcast tournament to relay external games.
    /// This endpoint accepts the same form data as the [web form](https://lichess.org/broadcast/new).
    ///
    ///
    /// - Remark: HTTP `POST /broadcast/new`.
    /// - Remark: Generated from `#/paths//broadcast/new/post(broadcastTourCreate)`.
    internal func broadcastTourCreate(_ input: Operations.broadcastTourCreate.Input) async throws -> Operations.broadcastTourCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastTourCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/broadcast/new",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastTourCreate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastTourCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastWithRounds.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastTourCreate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a broadcast tournament
    ///
    /// Get information about a broadcast tournament.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/{broadcastTournamentId}`.
    /// - Remark: Generated from `#/paths//api/broadcast/{broadcastTournamentId}/get(broadcastTourGet)`.
    internal func broadcastTourGet(_ input: Operations.broadcastTourGet.Input) async throws -> Operations.broadcastTourGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastTourGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/{}",
                    parameters: [
                        input.path.broadcastTournamentId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastTourGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastWithRounds.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get players of a broadcast
    ///
    /// Get the list of players of a broadcast tournament, if available.
    ///
    ///
    /// - Remark: HTTP `GET /broadcast/{broadcastTournamentId}/players`.
    /// - Remark: Generated from `#/paths//broadcast/{broadcastTournamentId}/players/get(broadcastPlayersGet)`.
    internal func broadcastPlayersGet(_ input: Operations.broadcastPlayersGet.Input) async throws -> Operations.broadcastPlayersGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastPlayersGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/broadcast/{}/players",
                    parameters: [
                        input.path.broadcastTournamentId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastPlayersGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BroadcastPlayerEntry].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update your broadcast tournament
    ///
    /// Update information about a broadcast tournament that you created.
    /// This endpoint accepts the same form data as the web form.
    /// All fields must be populated with data. Missing fields will override the broadcast with empty data.
    ///
    ///
    /// - Remark: HTTP `POST /broadcast/{broadcastTournamentId}/edit`.
    /// - Remark: Generated from `#/paths//broadcast/{broadcastTournamentId}/edit/post(broadcastTourUpdate)`.
    internal func broadcastTourUpdate(_ input: Operations.broadcastTourUpdate.Input) async throws -> Operations.broadcastTourUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastTourUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/broadcast/{}/edit",
                    parameters: [
                        input.path.broadcastTournamentId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastTourUpdate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastTourUpdate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastTourUpdate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a broadcast round
    ///
    /// Create a new broadcast round to relay external games.
    /// This endpoint accepts the same form data as the web form.
    ///
    /// Choose one between `syncUrl`, `syncUrls`, `syncIds` and `syncUsers`, if it is missing, the broadcast needs to be fed by [pushing PGN to it](#operation/broadcastPush)
    ///
    ///
    /// - Remark: HTTP `POST /broadcast/{broadcastTournamentId}/new`.
    /// - Remark: Generated from `#/paths//broadcast/{broadcastTournamentId}/new/post(broadcastRoundCreate)`.
    internal func broadcastRoundCreate(_ input: Operations.broadcastRoundCreate.Input) async throws -> Operations.broadcastRoundCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastRoundCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/broadcast/{}/new",
                    parameters: [
                        input.path.broadcastTournamentId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastRoundCreate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastRoundNew.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundCreate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a broadcast round
    ///
    /// Get information about a broadcast round.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}`.
    /// - Remark: Generated from `#/paths//api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}/get(broadcastRoundGet)`.
    internal func broadcastRoundGet(_ input: Operations.broadcastRoundGet.Input) async throws -> Operations.broadcastRoundGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastRoundGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/{}/{}/{}",
                    parameters: [
                        input.path.broadcastTournamentSlug,
                        input.path.broadcastRoundSlug,
                        input.path.broadcastRoundId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastRound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update a broadcast round
    ///
    /// Update information about a broadcast round.
    /// This endpoint accepts the same form data as the web form.
    /// All fields must be populated with data. Missing fields will override the broadcast with empty data.
    /// For instance, if you omit `startDate`, then any pre-existing start date will be removed.
    ///
    ///
    /// - Remark: HTTP `POST /broadcast/round/{broadcastRoundId}/edit`.
    /// - Remark: Generated from `#/paths//broadcast/round/{broadcastRoundId}/edit/post(broadcastRoundUpdate)`.
    internal func broadcastRoundUpdate(_ input: Operations.broadcastRoundUpdate.Input) async throws -> Operations.broadcastRoundUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastRoundUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/broadcast/round/{}/edit",
                    parameters: [
                        input.path.broadcastRoundId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastRoundUpdate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundUpdate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastRound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundUpdate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reset a broadcast round
    ///
    /// Remove any games from the broadcast round and reset it to its initial state.
    ///
    ///
    /// - Remark: HTTP `POST /api/broadcast/round/{broadcastRoundId}/reset`.
    /// - Remark: Generated from `#/paths//api/broadcast/round/{broadcastRoundId}/reset/post(broadcastRoundReset)`.
    internal func broadcastRoundReset(_ input: Operations.broadcastRoundReset.Input) async throws -> Operations.broadcastRoundReset.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastRoundReset.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/round/{}/reset",
                    parameters: [
                        input.path.broadcastRoundId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastRoundReset.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundReset.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Push PGN to a broadcast round
    ///
    /// Update a broadcast with new PGN.
    /// Only for broadcasts without a source URL.
    ///
    ///
    /// - Remark: HTTP `POST /api/broadcast/round/{broadcastRoundId}/push`.
    /// - Remark: Generated from `#/paths//api/broadcast/round/{broadcastRoundId}/push/post(broadcastPush)`.
    internal func broadcastPush(_ input: Operations.broadcastPush.Input) async throws -> Operations.broadcastPush.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastPush.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/round/{}/push",
                    parameters: [
                        input.path.broadcastRoundId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastPush.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastPush.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BroadcastPgnPush.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Operations.broadcastPush.Output.BadRequest.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastPush.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.broadcastPush.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream an ongoing broadcast round as PGN
    ///
    /// This streaming endpoint first sends all games of a broadcast round in PGN format.
    /// Then, it waits for new moves to be played. As soon as it happens, the entire PGN of the game is sent to the stream.
    /// The stream will also send PGNs when games are added to the round.
    /// This is the best way to get updates about an ongoing round. Streaming means no polling,
    /// and no pollings means no latency, and minimum impact on the server.
    ///
    ///
    /// - Remark: HTTP `GET /api/stream/broadcast/round/{broadcastRoundId}.pgn`.
    /// - Remark: Generated from `#/paths//api/stream/broadcast/round/{broadcastRoundId}.pgn/get(broadcastStreamRoundPgn)`.
    internal func broadcastStreamRoundPgn(_ input: Operations.broadcastStreamRoundPgn.Input) async throws -> Operations.broadcastStreamRoundPgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastStreamRoundPgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/stream/broadcast/round/{}.pgn",
                    parameters: [
                        input.path.broadcastRoundId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastStreamRoundPgn.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastStreamRoundPgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export one round as PGN
    ///
    /// Download all games of a single round of a broadcast tournament in PGN format.
    /// You *could* poll this endpoint to get updates about a tournament, but it would be slow,
    /// and very inefficient.
    /// Instead, consider [streaming the tournament](#operation/broadcastStreamRoundPgn) to get
    /// a new PGN every time a game is updated, in real-time.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/round/{broadcastRoundId}.pgn`.
    /// - Remark: Generated from `#/paths//api/broadcast/round/{broadcastRoundId}.pgn/get(broadcastRoundPgn)`.
    internal func broadcastRoundPgn(_ input: Operations.broadcastRoundPgn.Input) async throws -> Operations.broadcastRoundPgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastRoundPgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/round/{}.pgn",
                    parameters: [
                        input.path.broadcastRoundId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastRoundPgn.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastRoundPgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export all rounds as PGN
    ///
    /// Download all games of all rounds of a broadcast in PGN format.
    /// If a `study:read` [OAuth token](#tag/OAuth) is provided,
    /// the private rounds where the user is a contributor will be available.
    /// You may want to [download only the games of a single round](#operation/broadcastRoundPgn) instead.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/{broadcastTournamentId}.pgn`.
    /// - Remark: Generated from `#/paths//api/broadcast/{broadcastTournamentId}.pgn/get(broadcastAllRoundsPgn)`.
    internal func broadcastAllRoundsPgn(_ input: Operations.broadcastAllRoundsPgn.Input) async throws -> Operations.broadcastAllRoundsPgn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastAllRoundsPgn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/{}.pgn",
                    parameters: [
                        input.path.broadcastTournamentId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.broadcastAllRoundsPgn.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastAllRoundsPgn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get your broadcast rounds
    ///
    /// Stream all broadcast rounds you are a member of.
    /// Also includes broadcasts rounds you did not create, but were invited to.
    /// Also includes broadcasts rounds where you're a non-writing member. See the `writeable` flag in the response.
    /// Rounds are ordered by rank, which is roughly chronological, most recent first, slightly pondered with popularity.
    ///
    ///
    /// - Remark: HTTP `GET /api/broadcast/my-rounds`.
    /// - Remark: Generated from `#/paths//api/broadcast/my-rounds/get(broadcastMyRoundsGet)`.
    internal func broadcastMyRoundsGet(_ input: Operations.broadcastMyRoundsGet.Input) async throws -> Operations.broadcastMyRoundsGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.broadcastMyRoundsGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/broadcast/my-rounds",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.broadcastMyRoundsGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a FIDE player
    ///
    /// Get information about a FIDE player.
    ///
    ///
    /// - Remark: HTTP `GET /api/fide/player/{playerId}`.
    /// - Remark: Generated from `#/paths//api/fide/player/{playerId}/get(fidePlayerGet)`.
    internal func fidePlayerGet(_ input: Operations.fidePlayerGet.Input) async throws -> Operations.fidePlayerGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.fidePlayerGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/fide/player/{}",
                    parameters: [
                        input.path.playerId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.fidePlayerGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.FIDEPlayer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search FIDE players
    ///
    /// List of FIDE players search results for a query.
    ///
    ///
    /// - Remark: HTTP `GET /api/fide/player`.
    /// - Remark: Generated from `#/paths//api/fide/player/get(fidePlayerSearch)`.
    internal func fidePlayerSearch(_ input: Operations.fidePlayerSearch.Input) async throws -> Operations.fidePlayerSearch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.fidePlayerSearch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/fide/player",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "q",
                    value: input.query.q
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.fidePlayerSearch.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.fidePlayerSearch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.FIDEPlayer].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get current simuls
    ///
    /// Get recently created, started, finished, simuls.
    /// Created and finished simul lists are not exhaustives, only those with
    /// strong enough host will be listed, the same filter is used to display simuls on https://lichess.org/simul.
    /// When [authenticated with OAuth2](#section/Introduction/Authentication), the pending list will be populated with your created, but unstarted simuls.
    ///
    ///
    /// - Remark: HTTP `GET /api/simul`.
    /// - Remark: Generated from `#/paths//api/simul/get(apiSimul)`.
    internal func apiSimul(_ input: Operations.apiSimul.Input) async throws -> Operations.apiSimul.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiSimul.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/simul",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiSimul.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiSimul.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiSimul.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a single team
    ///
    /// Public info about a team. Includes the list of publicly visible leaders.
    ///
    /// - Remark: HTTP `GET /api/team/{teamId}`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/get(teamShow)`.
    internal func teamShow(_ input: Operations.teamShow.Input) async throws -> Operations.teamShow.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamShow.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamShow.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamShow.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Team.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get popular teams
    ///
    /// Paginator of the most popular teams.
    ///
    ///
    /// - Remark: HTTP `GET /api/team/all`.
    /// - Remark: Generated from `#/paths//api/team/all/get(teamAll)`.
    internal func teamAll(_ input: Operations.teamAll.Input) async throws -> Operations.teamAll.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamAll.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/all",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamAll.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamAll.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TeamPaginatorJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Teams of a player
    ///
    /// All the teams a player is a member of.
    ///
    ///
    /// - Remark: HTTP `GET /api/team/of/{username}`.
    /// - Remark: Generated from `#/paths//api/team/of/{username}/get(teamOfUsername)`.
    internal func teamOfUsername(_ input: Operations.teamOfUsername.Input) async throws -> Operations.teamOfUsername.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamOfUsername.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/of/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamOfUsername.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamOfUsername.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Team].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search teams
    ///
    /// Paginator of team search results for a keyword.
    ///
    ///
    /// - Remark: HTTP `GET /api/team/search`.
    /// - Remark: Generated from `#/paths//api/team/search/get(teamSearch)`.
    internal func teamSearch(_ input: Operations.teamSearch.Input) async throws -> Operations.teamSearch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamSearch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "text",
                    value: input.query.text
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamSearch.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamSearch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TeamPaginatorJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get members of a team
    ///
    /// Members are sorted by reverse chronological order of joining the team (most recent first).
    /// OAuth is only required if the list of members is private.
    /// Up to 5,000 users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    ///
    /// - Remark: HTTP `GET /api/team/{teamId}/users`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/users/get(teamIdUsers)`.
    internal func teamIdUsers(_ input: Operations.teamIdUsers.Input) async throws -> Operations.teamIdUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamIdUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/users",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "full",
                    value: input.query.full
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamIdUsers.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamIdUsers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get team Arena tournaments
    ///
    /// Get all Arena tournaments relevant to a team.
    /// Tournaments are sorted by reverse chronological order of start date (last starting first).
    /// Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    ///
    /// - Remark: HTTP `GET /api/team/{teamId}/arena`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/arena/get(apiTeamArena)`.
    internal func apiTeamArena(_ input: Operations.apiTeamArena.Input) async throws -> Operations.apiTeamArena.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTeamArena.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/arena",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "max",
                    value: input.query.max
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "status",
                    value: input.query.status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdBy",
                    value: input.query.createdBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiTeamArena.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiTeamArena.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Join a team
    ///
    /// Join a team.
    /// If the team requires a password but the `password` field is incorrect,
    /// then the call fails with `403 Forbidden`.
    /// Similarly, if the team join policy requires a confirmation but the
    /// `message` parameter is not given, then the call fails with
    /// `403 Forbidden`.
    ///
    ///
    /// - Remark: HTTP `POST /team/{teamId}/join`.
    /// - Remark: Generated from `#/paths//team/{teamId}/join/post(teamIdJoin)`.
    internal func teamIdJoin(_ input: Operations.teamIdJoin.Input) async throws -> Operations.teamIdJoin.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamIdJoin.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/team/{}/join",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamIdJoin.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Leave a team
    ///
    /// Leave a team.
    /// - <https://lichess.org/team>
    ///
    ///
    /// - Remark: HTTP `POST /team/{teamId}/quit`.
    /// - Remark: Generated from `#/paths//team/{teamId}/quit/post(teamIdQuit)`.
    internal func teamIdQuit(_ input: Operations.teamIdQuit.Input) async throws -> Operations.teamIdQuit.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamIdQuit.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/team/{}/quit",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamIdQuit.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get join requests
    ///
    /// Get pending join requests of your team
    ///
    /// - Remark: HTTP `GET /api/team/{teamId}/requests`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/requests/get(teamRequests)`.
    internal func teamRequests(_ input: Operations.teamRequests.Input) async throws -> Operations.teamRequests.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamRequests.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/requests",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "declined",
                    value: input.query.declined
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamRequests.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.TeamRequestWithUser].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Accept join request
    ///
    /// Accept someone's request to join your team
    ///
    /// - Remark: HTTP `POST /api/team/{teamId}/request/{userId}/accept`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/request/{userId}/accept/post(teamRequestAccept)`.
    internal func teamRequestAccept(_ input: Operations.teamRequestAccept.Input) async throws -> Operations.teamRequestAccept.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamRequestAccept.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/request/{}/accept",
                    parameters: [
                        input.path.teamId,
                        input.path.userId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamRequestAccept.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Decline join request
    ///
    /// Decline someone's request to join your team
    ///
    /// - Remark: HTTP `POST /api/team/{teamId}/request/{userId}/decline`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/request/{userId}/decline/post(teamRequestDecline)`.
    internal func teamRequestDecline(_ input: Operations.teamRequestDecline.Input) async throws -> Operations.teamRequestDecline.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamRequestDecline.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/request/{}/decline",
                    parameters: [
                        input.path.teamId,
                        input.path.userId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamRequestDecline.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Kick a user from your team
    ///
    /// Kick a member out of one of your teams.
    /// - <https://lichess.org/team>
    ///
    ///
    /// - Remark: HTTP `POST /api/team/{teamId}/kick/{userId}`.
    /// - Remark: Generated from `#/paths//api/team/{teamId}/kick/{userId}/post(teamIdKickUserId)`.
    internal func teamIdKickUserId(_ input: Operations.teamIdKickUserId.Input) async throws -> Operations.teamIdKickUserId.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamIdKickUserId.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/team/{}/kick/{}",
                    parameters: [
                        input.path.teamId,
                        input.path.userId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamIdKickUserId.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Message all members
    ///
    /// Send a private message to all members of a team.
    /// You must be a team leader with the "Messages" permission.
    ///
    ///
    /// - Remark: HTTP `POST /team/{teamId}/pm-all`.
    /// - Remark: Generated from `#/paths//team/{teamId}/pm-all/post(teamIdPmAll)`.
    internal func teamIdPmAll(_ input: Operations.teamIdPmAll.Input) async throws -> Operations.teamIdPmAll.Output {
        try await client.send(
            input: input,
            forOperation: Operations.teamIdPmAll.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/team/{}/pm-all",
                    parameters: [
                        input.path.teamId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.teamIdPmAll.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamIdPmAll.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.teamIdPmAll.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get live streamers
    ///
    /// Get basic info about currently streaming users.
    /// This API is very fast and cheap on lichess side.
    /// So you can call it quite often (like once every 5 seconds).
    ///
    ///
    /// - Remark: HTTP `GET /api/streamer/live`.
    /// - Remark: Generated from `#/paths//api/streamer/live/get(streamerLive)`.
    internal func streamerLive(_ input: Operations.streamerLive.Input) async throws -> Operations.streamerLive.Output {
        try await client.send(
            input: input,
            forOperation: Operations.streamerLive.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/streamer/live",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.streamerLive.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.streamerLive.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.streamerLive.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get crosstable
    ///
    /// Get total number of games, and current score, of any two users.
    /// If the `matchup` flag is provided, and the users are currently playing, also gets the current match game number and scores.
    ///
    ///
    /// - Remark: HTTP `GET /api/crosstable/{user1}/{user2}`.
    /// - Remark: Generated from `#/paths//api/crosstable/{user1}/{user2}/get(apiCrosstable)`.
    internal func apiCrosstable(_ input: Operations.apiCrosstable.Input) async throws -> Operations.apiCrosstable.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiCrosstable.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/crosstable/{}/{}",
                    parameters: [
                        input.path.user1,
                        input.path.user2
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "matchup",
                    value: input.query.matchup
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiCrosstable.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiCrosstable.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Crosstable.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Autocomplete usernames
    ///
    /// Provides autocompletion options for an incomplete username.
    ///
    ///
    /// - Remark: HTTP `GET /api/player/autocomplete`.
    /// - Remark: Generated from `#/paths//api/player/autocomplete/get(apiPlayerAutocomplete)`.
    internal func apiPlayerAutocomplete(_ input: Operations.apiPlayerAutocomplete.Input) async throws -> Operations.apiPlayerAutocomplete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiPlayerAutocomplete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/player/autocomplete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "term",
                    value: input.query.term
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "object",
                    value: input.query.object
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "names",
                    value: input.query.names
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "friend",
                    value: input.query.friend
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "team",
                    value: input.query.team
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tour",
                    value: input.query.tour
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "swiss",
                    value: input.query.swiss
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiPlayerAutocomplete.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiPlayerAutocomplete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiPlayerAutocomplete.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get notes for a user
    ///
    /// Get the private notes that you have added for a user.
    ///
    ///
    /// - Remark: HTTP `GET /api/user/{username}/note`.
    /// - Remark: Generated from `#/paths//api/user/{username}/note/get(readNote)`.
    internal func readNote(_ input: Operations.readNote.Input) async throws -> Operations.readNote.Output {
        try await client.send(
            input: input,
            forOperation: Operations.readNote.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/note",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.readNote.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.readNote.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.UserNote].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add a note for a user
    ///
    /// Add a private note available only to you about this account.
    ///
    ///
    /// - Remark: HTTP `POST /api/user/{username}/note`.
    /// - Remark: Generated from `#/paths//api/user/{username}/note/post(writeNote)`.
    internal func writeNote(_ input: Operations.writeNote.Input) async throws -> Operations.writeNote.Output {
        try await client.send(
            input: input,
            forOperation: Operations.writeNote.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/user/{}/note",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.writeNote.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get users followed by the logged in user
    ///
    /// Users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    ///
    /// - Remark: HTTP `GET /api/rel/following`.
    /// - Remark: Generated from `#/paths//api/rel/following/get(apiUserFollowing)`.
    internal func apiUserFollowing(_ input: Operations.apiUserFollowing.Input) async throws -> Operations.apiUserFollowing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiUserFollowing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/rel/following",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiUserFollowing.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiUserFollowing.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Follow a player
    ///
    /// Follow a player, adding them to your list of Lichess friends.
    ///
    ///
    /// - Remark: HTTP `POST /api/rel/follow/{username}`.
    /// - Remark: Generated from `#/paths//api/rel/follow/{username}/post(followUser)`.
    internal func followUser(_ input: Operations.followUser.Input) async throws -> Operations.followUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.followUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/rel/follow/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.followUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unfollow a player
    ///
    /// Unfollow a player, removing them from your list of Lichess friends.
    ///
    ///
    /// - Remark: HTTP `POST /api/rel/unfollow/{username}`.
    /// - Remark: Generated from `#/paths//api/rel/unfollow/{username}/post(unfollowUser)`.
    internal func unfollowUser(_ input: Operations.unfollowUser.Input) async throws -> Operations.unfollowUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.unfollowUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/rel/unfollow/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.unfollowUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Block a player
    ///
    /// Block a player, adding them to your list of blocked Lichess users.
    ///
    ///
    /// - Remark: HTTP `POST /api/rel/block/{username}`.
    /// - Remark: Generated from `#/paths//api/rel/block/{username}/post(blockUser)`.
    internal func blockUser(_ input: Operations.blockUser.Input) async throws -> Operations.blockUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.blockUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/rel/block/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.blockUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unblock a player
    ///
    /// Unblock a player, removing them from your list of blocked Lichess users.
    ///
    ///
    /// - Remark: HTTP `POST /api/rel/unblock/{username}`.
    /// - Remark: Generated from `#/paths//api/rel/unblock/{username}/post(unblockUser)`.
    internal func unblockUser(_ input: Operations.unblockUser.Input) async throws -> Operations.unblockUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.unblockUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/rel/unblock/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.unblockUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream incoming events
    ///
    /// Stream the events reaching a lichess user in real time as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    /// An empty line is sent every 7 seconds for keep alive purposes.
    ///
    /// Each non-empty line is a JSON object containing a `type` field. Possible values are:
    /// - `gameStart` Start of a game
    /// - `gameFinish` Completion of a game
    /// - `challenge` A player sends you a challenge or you challenge someone
    /// - `challengeCanceled` A player cancels their challenge to you
    /// - `challengeDeclined` The opponent declines your challenge
    ///
    /// When the stream opens, all current challenges and games are sent.
    ///
    /// Only one global event stream can be active at a time. When the stream opens, the previous one with the same access token is closed.
    ///
    ///
    /// - Remark: HTTP `GET /api/stream/event`.
    /// - Remark: Generated from `#/paths//api/stream/event/get(apiStreamEvent)`.
    internal func apiStreamEvent(_ input: Operations.apiStreamEvent.Input) async throws -> Operations.apiStreamEvent.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiStreamEvent.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/stream/event",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiStreamEvent.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiStreamEvent.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a seek
    ///
    /// Create a public seek, to start a game with a random player.
    ///
    /// ### Real-time seek
    ///
    /// Specify the `time` and `increment` clock values.
    /// The response is streamed but doesn't contain any information.
    ///
    /// **Keep the connection open to keep the seek active**.
    ///
    /// If the client closes the connection, the seek is canceled. This way, if the client terminates, the user won't be paired in a game they wouldn't play.
    /// When the seek is accepted, or expires, the server closes the connection.
    ///
    /// **Make sure to also have an [Event stream](#operation/apiStreamEvent) open**, to be notified when a game starts.
    /// We recommend opening the [Event stream](#operation/apiStreamEvent) first, then the seek stream. This way,
    /// you won't miss the game event if the seek is accepted immediately.
    ///
    /// ### Correspondence seek
    ///
    /// Specify the `days` per turn value.
    /// The response is not streamed, it immediately completes with the seek ID. The seek remains active on the server until it is joined by someone.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/seek`.
    /// - Remark: Generated from `#/paths//api/board/seek/post(apiBoardSeek)`.
    internal func apiBoardSeek(_ input: Operations.apiBoardSeek.Input) async throws -> Operations.apiBoardSeek.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiBoardSeek.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/seek",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiBoardSeek.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiBoardSeek.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiBoardSeek.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiBoardSeek.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Board game state
    ///
    /// Stream the state of a game being played with the Board API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    ///
    /// Use this endpoint to get updates about the game in real-time, with a single request.
    ///
    /// Each line is a JSON object containing a `type` field. Possible values are:
    ///   - `gameFull` Full game data. All values are immutable, except for the `state` field.
    ///   - `gameState` Current state of the game. Immutable values not included. Sent when a move is played, a draw is offered, or when the game ends.
    ///   - `chatLine` Chat message sent by a user in the `room` "player" or "spectator".
    ///   - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
    ///
    /// The first line is always of type `gameFull`.
    ///
    /// The server closes the stream when the game ends, or if the game has already ended.
    ///
    ///
    /// - Remark: HTTP `GET /api/board/game/stream/{gameId}`.
    /// - Remark: Generated from `#/paths//api/board/game/stream/{gameId}/get(boardGameStream)`.
    internal func boardGameStream(_ input: Operations.boardGameStream.Input) async throws -> Operations.boardGameStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/stream/{}",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameStream.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameStream.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameStream.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Make a Board move
    ///
    /// Make a move in a game being played with the Board API.
    /// The move can also contain a draw offer/agreement.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/move/{move}`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/move/{move}/post(boardGameMove)`.
    internal func boardGameMove(_ input: Operations.boardGameMove.Input) async throws -> Operations.boardGameMove.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameMove.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/move/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.move
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offeringDraw",
                    value: input.query.offeringDraw
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameMove.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameMove.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameMove.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Fetch the game chat
    ///
    /// Get the messages posted in the game chat
    ///
    ///
    /// - Remark: HTTP `GET /api/board/game/{gameId}/chat`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/chat/get(boardGameChatGet)`.
    internal func boardGameChatGet(_ input: Operations.boardGameChatGet.Input) async throws -> Operations.boardGameChatGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameChatGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/chat",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameChatGet.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameChatGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Write in the chat
    ///
    /// Post a message to the player or spectator chat, in a game being played with the Board API.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/chat`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/chat/post(boardGameChatPost)`.
    internal func boardGameChatPost(_ input: Operations.boardGameChatPost.Input) async throws -> Operations.boardGameChatPost.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameChatPost.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/chat",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameChatPost.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameChatPost.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameChatPost.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Abort a game
    ///
    /// Abort a game being played with the Board API.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/abort`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/abort/post(boardGameAbort)`.
    internal func boardGameAbort(_ input: Operations.boardGameAbort.Input) async throws -> Operations.boardGameAbort.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameAbort.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/abort",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameAbort.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameAbort.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameAbort.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Resign a game
    ///
    /// Resign a game being played with the Board API.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/resign`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/resign/post(boardGameResign)`.
    internal func boardGameResign(_ input: Operations.boardGameResign.Input) async throws -> Operations.boardGameResign.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameResign.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/resign",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameResign.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameResign.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameResign.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Handle draw offers
    ///
    /// Create/accept/decline draw offers.
    /// - `yes`: Offer a draw, or accept the opponent's draw offer.
    /// - `no`: Decline a draw offer from the opponent.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/draw/{accept}`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/draw/{accept}/post(boardGameDraw)`.
    internal func boardGameDraw(_ input: Operations.boardGameDraw.Input) async throws -> Operations.boardGameDraw.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameDraw.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/draw/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.accept
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameDraw.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameDraw.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameDraw.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Handle takeback offers
    ///
    /// Create/accept/decline takebacks.
    /// - `yes`: Propose a takeback, or accept the opponent's takeback offer.
    /// - `no`: Decline a takeback offer from the opponent.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/takeback/{accept}`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/takeback/{accept}/post(boardGameTakeback)`.
    internal func boardGameTakeback(_ input: Operations.boardGameTakeback.Input) async throws -> Operations.boardGameTakeback.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameTakeback.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/takeback/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.accept
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameTakeback.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameTakeback.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameTakeback.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Claim victory of a game
    ///
    /// Claim victory when the opponent has left the game for a while.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/claim-victory`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/claim-victory/post(boardGameClaimVictory)`.
    internal func boardGameClaimVictory(_ input: Operations.boardGameClaimVictory.Input) async throws -> Operations.boardGameClaimVictory.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameClaimVictory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/claim-victory",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameClaimVictory.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameClaimVictory.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameClaimVictory.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Claim draw of a game
    ///
    /// Claim draw when the opponent has left the game for a while.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/claim-draw`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/claim-draw/post(boardGameClaimDraw)`.
    internal func boardGameClaimDraw(_ input: Operations.boardGameClaimDraw.Input) async throws -> Operations.boardGameClaimDraw.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameClaimDraw.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/claim-draw",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameClaimDraw.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameClaimDraw.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameClaimDraw.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Berserk a tournament game
    ///
    /// Go berserk on an arena tournament game. Halves the clock time, grants an extra point upon winning.
    /// Only available in arena tournaments that allow berserk, and before each player has made a move.
    ///
    ///
    /// - Remark: HTTP `POST /api/board/game/{gameId}/berserk`.
    /// - Remark: Generated from `#/paths//api/board/game/{gameId}/berserk/post(boardGameBerserk)`.
    internal func boardGameBerserk(_ input: Operations.boardGameBerserk.Input) async throws -> Operations.boardGameBerserk.Output {
        try await client.send(
            input: input,
            forOperation: Operations.boardGameBerserk.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/board/game/{}/berserk",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.boardGameBerserk.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameBerserk.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.boardGameBerserk.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get online bots
    ///
    /// Stream the [online bot users](https://lichess.org/player/bots), as [ndjson](#section/Introduction/Streaming-with-ND-JSON). Throttled to 50 bot users per second.
    ///
    /// - Remark: HTTP `GET /api/bot/online`.
    /// - Remark: Generated from `#/paths//api/bot/online/get(apiBotOnline)`.
    internal func apiBotOnline(_ input: Operations.apiBotOnline.Input) async throws -> Operations.apiBotOnline.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiBotOnline.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/online",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nb",
                    value: input.query.nb
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiBotOnline.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiBotOnline.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Upgrade to Bot account
    ///
    /// Upgrade a lichess player account into a Bot account. Only Bot accounts can use the Bot API.
    /// The account **cannot have played any game** before becoming a Bot account. The upgrade is **irreversible**. The account will only be able to play as a Bot.
    /// To upgrade an account to Bot, use the [official lichess-bot client](https://github.com/lichess-bot-devs/lichess-bot), or follow these steps:
    /// - Create an [API access token](https://lichess.org/account/oauth/token/create?scopes[]=bot:play) with "Play bot moves" permission.
    /// - `curl -d '' https://lichess.org/api/bot/account/upgrade -H "Authorization: Bearer <yourTokenHere>"`
    /// To know if an account has already been upgraded, use the [Get my profile API](#operation/accountMe):
    /// the `title` field should be set to `BOT`.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/account/upgrade`.
    /// - Remark: Generated from `#/paths//api/bot/account/upgrade/post(botAccountUpgrade)`.
    internal func botAccountUpgrade(_ input: Operations.botAccountUpgrade.Input) async throws -> Operations.botAccountUpgrade.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botAccountUpgrade.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/account/upgrade",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botAccountUpgrade.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botAccountUpgrade.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botAccountUpgrade.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Bot game state
    ///
    /// Stream the state of a game being played with the Bot API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
    /// Use this endpoint to get updates about the game in real-time, with a single request.
    /// Each line is a JSON object containing a `type` field. Possible values are:
    /// - `gameFull` Full game data. All values are immutable, except for the `state` field.
    /// - `gameState` Current state of the game. Immutable values not included.
    /// - `chatLine` Chat message sent by a user (or the bot itself) in the `room` "player" or "spectator".
    /// - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
    /// The first line is always of type `gameFull`.
    ///
    ///
    /// - Remark: HTTP `GET /api/bot/game/stream/{gameId}`.
    /// - Remark: Generated from `#/paths//api/bot/game/stream/{gameId}/get(botGameStream)`.
    internal func botGameStream(_ input: Operations.botGameStream.Input) async throws -> Operations.botGameStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/stream/{}",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameStream.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameStream.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameStream.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Make a Bot move
    ///
    /// Make a move in a game being played with the Bot API.
    /// The move can also contain a draw offer/agreement.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/move/{move}`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/move/{move}/post(botGameMove)`.
    internal func botGameMove(_ input: Operations.botGameMove.Input) async throws -> Operations.botGameMove.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameMove.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/move/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.move
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offeringDraw",
                    value: input.query.offeringDraw
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameMove.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameMove.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameMove.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Fetch the game chat
    ///
    /// Get the messages posted in the game chat
    ///
    ///
    /// - Remark: HTTP `GET /api/bot/game/{gameId}/chat`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/chat/get(botGameChatGet)`.
    internal func botGameChatGet(_ input: Operations.botGameChatGet.Input) async throws -> Operations.botGameChatGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameChatGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/chat",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameChatGet.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameChatGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Write in the chat
    ///
    /// Post a message to the player or spectator chat, in a game being played with the Bot API.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/chat`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/chat/post(botGameChat)`.
    internal func botGameChat(_ input: Operations.botGameChat.Input) async throws -> Operations.botGameChat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameChat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/chat",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameChat.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameChat.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameChat.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Abort a game
    ///
    /// Abort a game being played with the Bot API.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/abort`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/abort/post(botGameAbort)`.
    internal func botGameAbort(_ input: Operations.botGameAbort.Input) async throws -> Operations.botGameAbort.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameAbort.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/abort",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameAbort.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameAbort.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameAbort.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Resign a game
    ///
    /// Resign a game being played with the Bot API.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/resign`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/resign/post(botGameResign)`.
    internal func botGameResign(_ input: Operations.botGameResign.Input) async throws -> Operations.botGameResign.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameResign.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/resign",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameResign.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameResign.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameResign.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Handle draw offers
    ///
    /// Create/accept/decline draw offers with the Bot API.
    /// - `yes`: Offer a draw, or accept the opponent's draw offer.
    /// - `no`: Decline a draw offer from the opponent.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/draw/{accept}`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/draw/{accept}/post(botGameDraw)`.
    internal func botGameDraw(_ input: Operations.botGameDraw.Input) async throws -> Operations.botGameDraw.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameDraw.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/draw/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.accept
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameDraw.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameDraw.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameDraw.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Handle takeback offers
    ///
    /// Create/accept/decline takebacks with the Bot API.
    /// - `yes`: Propose a takeback, or accept the opponent's takeback offer.
    /// - `no`: Decline a takeback offer from the opponent.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/takeback/{accept}`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/takeback/{accept}/post(botGameTakeback)`.
    internal func botGameTakeback(_ input: Operations.botGameTakeback.Input) async throws -> Operations.botGameTakeback.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameTakeback.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/takeback/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.accept
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameTakeback.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameTakeback.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameTakeback.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Claim victory of a game
    ///
    /// Claim victory when the opponent has left the game for a while.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/claim-victory`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/claim-victory/post(botGameClaimVictory)`.
    internal func botGameClaimVictory(_ input: Operations.botGameClaimVictory.Input) async throws -> Operations.botGameClaimVictory.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameClaimVictory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/claim-victory",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameClaimVictory.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameClaimVictory.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameClaimVictory.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Claim draw of a game
    ///
    /// Claim draw when the opponent has left the game for a while.
    ///
    ///
    /// - Remark: HTTP `POST /api/bot/game/{gameId}/claim-draw`.
    /// - Remark: Generated from `#/paths//api/bot/game/{gameId}/claim-draw/post(botGameClaimDraw)`.
    internal func botGameClaimDraw(_ input: Operations.botGameClaimDraw.Input) async throws -> Operations.botGameClaimDraw.Output {
        try await client.send(
            input: input,
            forOperation: Operations.botGameClaimDraw.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bot/game/{}/claim-draw",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.botGameClaimDraw.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameClaimDraw.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.botGameClaimDraw.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List your challenges
    ///
    /// Get a list of challenges created by or targeted at you.
    ///
    ///
    /// - Remark: HTTP `GET /api/challenge`.
    /// - Remark: Generated from `#/paths//api/challenge/get(challengeList)`.
    internal func challengeList(_ input: Operations.challengeList.Input) async throws -> Operations.challengeList.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeList.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeList.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeList.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.challengeList.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a challenge
    ///
    /// Challenge someone to play. The targeted player can choose to accept or decline.
    /// If the challenge is accepted, you will be notified on the [event stream](#operation/apiStreamEvent)
    /// that a new game has started. The game ID will be the same as the challenge ID.
    /// Challenges for realtime games (not correspondence) expire after 20s if not accepted.
    /// To prevent that, use the `keepAliveStream` flag described below.
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/{username}`.
    /// - Remark: Generated from `#/paths//api/challenge/{username}/post(challengeCreate)`.
    internal func challengeCreate(_ input: Operations.challengeCreate.Input) async throws -> Operations.challengeCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeCreate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChallengeJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeCreate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Show one challenge
    ///
    /// Get details about a challenge, even if it has been recently accepted, canceled or declined.
    ///
    ///
    /// - Remark: HTTP `GET /api/challenge/{challengeId}/show`.
    /// - Remark: Generated from `#/paths//api/challenge/{challengeId}/show/get(challengeShow)`.
    internal func challengeShow(_ input: Operations.challengeShow.Input) async throws -> Operations.challengeShow.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeShow.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/{}/show",
                    parameters: [
                        input.path.challengeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeShow.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeShow.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChallengeJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Accept a challenge
    ///
    /// Accept an incoming challenge.
    /// You should receive a `gameStart` event on the [incoming events stream](#operation/apiStreamEvent).
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/{challengeId}/accept`.
    /// - Remark: Generated from `#/paths//api/challenge/{challengeId}/accept/post(challengeAccept)`.
    internal func challengeAccept(_ input: Operations.challengeAccept.Input) async throws -> Operations.challengeAccept.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeAccept.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/{}/accept",
                    parameters: [
                        input.path.challengeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "color",
                    value: input.query.color
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeAccept.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeAccept.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeAccept.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Decline a challenge
    ///
    /// Decline an incoming challenge.
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/{challengeId}/decline`.
    /// - Remark: Generated from `#/paths//api/challenge/{challengeId}/decline/post(challengeDecline)`.
    internal func challengeDecline(_ input: Operations.challengeDecline.Input) async throws -> Operations.challengeDecline.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeDecline.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/{}/decline",
                    parameters: [
                        input.path.challengeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeDecline.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeDecline.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeDecline.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancel a challenge
    ///
    /// Cancel a challenge you sent, or aborts the game if the challenge was accepted, but the game was not yet played.
    /// Note that the ID of a game is the same as the ID of the challenge that created it.
    /// Works for user challenges and open challenges alike.
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/{challengeId}/cancel`.
    /// - Remark: Generated from `#/paths//api/challenge/{challengeId}/cancel/post(challengeCancel)`.
    internal func challengeCancel(_ input: Operations.challengeCancel.Input) async throws -> Operations.challengeCancel.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeCancel.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/{}/cancel",
                    parameters: [
                        input.path.challengeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opponentToken",
                    value: input.query.opponentToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeCancel.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeCancel.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeCancel.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Challenge the AI
    ///
    /// Start a game with Lichess AI.
    /// You will be notified on the [event stream](#operation/apiStreamEvent) that a new game has started.
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/ai`.
    /// - Remark: Generated from `#/paths//api/challenge/ai/post(challengeAi)`.
    internal func challengeAi(_ input: Operations.challengeAi.Input) async throws -> Operations.challengeAi.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeAi.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/ai",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let headers: Operations.challengeAi.Output.Created.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeAi.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.challengeAi.Output.Created.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeAi.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Open-ended challenge
    ///
    /// Create a challenge that any 2 players can join.
    /// Share the URL of the challenge. the first 2 players to click it will be paired for a game.
    /// The response body also contains `whiteUrl` and `blackUrl`.
    /// You can control which color each player gets by giving them these URLs,
    /// instead of the main challenge URL.
    /// Open challenges expire after 24h.
    /// If the challenge creation is [authenticated with OAuth2](#section/Introduction/Authentication),
    /// then you can use the [challenge cancel endpoint](#operation/challengeCancel) to cancel it.
    /// To directly pair 2 known players, use [this endpoint](#operation/bulkPairingList) instead.
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/open`.
    /// - Remark: Generated from `#/paths//api/challenge/open/post(challengeOpen)`.
    internal func challengeOpen(_ input: Operations.challengeOpen.Input) async throws -> Operations.challengeOpen.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeOpen.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/open",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeOpen.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeOpen.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChallengeOpenJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeOpen.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start clocks of a game
    ///
    /// Start the clocks of a game immediately, even if a player has not yet made a move.
    /// Requires the OAuth tokens of both players with `challenge:write` scope.
    /// If the clocks have already started, the call will have no effect.
    ///
    /// For AI games with only one player, omit the `token2` parameter.
    ///
    ///
    /// - Remark: HTTP `POST /api/challenge/{gameId}/start-clocks`.
    /// - Remark: Generated from `#/paths//api/challenge/{gameId}/start-clocks/post(challengeStartClocks)`.
    internal func challengeStartClocks(_ input: Operations.challengeStartClocks.Input) async throws -> Operations.challengeStartClocks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.challengeStartClocks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/challenge/{}/start-clocks",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "token1",
                    value: input.query.token1
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "token2",
                    value: input.query.token2
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.challengeStartClocks.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.challengeStartClocks.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// View your bulk pairings
    ///
    /// Get a list of bulk pairings you created.
    ///
    ///
    /// - Remark: HTTP `GET /api/bulk-pairing`.
    /// - Remark: Generated from `#/paths//api/bulk-pairing/get(bulkPairingList)`.
    internal func bulkPairingList(_ input: Operations.bulkPairingList.Input) async throws -> Operations.bulkPairingList.Output {
        try await client.send(
            input: input,
            forOperation: Operations.bulkPairingList.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bulk-pairing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.bulkPairingList.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingList.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BulkPairing].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a bulk pairing
    ///
    /// Schedule many games at once, up to 24h in advance.
    /// OAuth tokens are required for all paired players, with the `challenge:write` scope.
    /// You can schedule up to 500 games every 10 minutes. [Contact us](mailto:contact@lichess.org) if you need higher limits.
    /// If games have a real-time clock, each player must have only one pairing.
    /// For correspondence games, players can have multiple pairings within the same bulk.
    ///
    /// **The entire bulk is rejected if:**
    ///   - a token is missing
    ///   - a token is present more than once (except in correspondence)
    ///   - a token lacks the `challenge:write` scope
    ///   - a player account is closed
    ///   - a player is paired more than once (except in correspondence)
    ///   - a bulk is already scheduled to start at the same time with the same player
    ///   - you have 20 scheduled bulks
    ///   - you have 1000 scheduled games
    ///
    /// Partial bulks are never created. Either it all fails, or it all succeeds.
    /// When it fails, it does so with an error message explaining the issue.
    /// Failed bulks are not counted in the rate limiting, they are free.
    /// Fix the issues, manually or programmatically, then retry to schedule the bulk.
    /// A successful bulk creation returns a JSON bulk document. Its ID can be used for further operations.
    ///
    ///
    /// - Remark: HTTP `POST /api/bulk-pairing`.
    /// - Remark: Generated from `#/paths//api/bulk-pairing/post(bulkPairingCreate)`.
    internal func bulkPairingCreate(_ input: Operations.bulkPairingCreate.Input) async throws -> Operations.bulkPairingCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.bulkPairingCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bulk-pairing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.bulkPairingCreate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BulkPairing.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingCreate.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Manually start clocks
    ///
    /// Immediately start all clocks of the games of a bulk pairing.
    /// This overrides the `startClocksAt` value of an existing bulk pairing.
    /// If the games have not yet been created (`bulk.pairAt` is in the future), then this does nothing.
    /// If the clocks have already started (`bulk.startClocksAt` is in the past), then this does nothing.
    ///
    ///
    /// - Remark: HTTP `POST /api/bulk-pairing/{id}/start-clocks`.
    /// - Remark: Generated from `#/paths//api/bulk-pairing/{id}/start-clocks/post(bulkPairingStartClocks)`.
    internal func bulkPairingStartClocks(_ input: Operations.bulkPairingStartClocks.Input) async throws -> Operations.bulkPairingStartClocks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.bulkPairingStartClocks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bulk-pairing/{}/start-clocks",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.bulkPairingStartClocks.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingStartClocks.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingStartClocks.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Show a bulk pairing
    ///
    /// Get a single bulk pairing by its ID.
    ///
    ///
    /// - Remark: HTTP `GET /api/bulk-pairing/{id}`.
    /// - Remark: Generated from `#/paths//api/bulk-pairing/{id}/get(bulkPairingGet)`.
    internal func bulkPairingGet(_ input: Operations.bulkPairingGet.Input) async throws -> Operations.bulkPairingGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.bulkPairingGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bulk-pairing/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.bulkPairingGet.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BulkPairing.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingGet.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancel a bulk pairing
    ///
    /// Cancel and delete a bulk pairing that is scheduled in the future.
    /// If the games have already been created, then this does nothing.
    /// Canceling a bulk pairing does not refund the rate limit cost of that bulk pairing.
    ///
    ///
    /// - Remark: HTTP `DELETE /api/bulk-pairing/{id}`.
    /// - Remark: Generated from `#/paths//api/bulk-pairing/{id}/delete(bulkPairingDelete)`.
    internal func bulkPairingDelete(_ input: Operations.bulkPairingDelete.Input) async throws -> Operations.bulkPairingDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.bulkPairingDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bulk-pairing/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.bulkPairingDelete.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingDelete.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NotFound.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Export games of a bulk pairing
    ///
    /// Download games of a bulk in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
    ///
    ///
    /// - Remark: HTTP `GET /api/bulk-pairing/{id}/games`.
    /// - Remark: Generated from `#/paths//api/bulk-pairing/{id}/games/get(bulkPairingIdGamesGet)`.
    internal func bulkPairingIdGamesGet(_ input: Operations.bulkPairingIdGamesGet.Input) async throws -> Operations.bulkPairingIdGamesGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.bulkPairingIdGamesGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/bulk-pairing/{}/games",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pgnInJson",
                    value: input.query.pgnInJson
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "clocks",
                    value: input.query.clocks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "evals",
                    value: input.query.evals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accuracy",
                    value: input.query.accuracy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "opening",
                    value: input.query.opening
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "division",
                    value: input.query.division
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "literate",
                    value: input.query.literate
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.bulkPairingIdGamesGet.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.bulkPairingIdGamesGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn",
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add time to the opponent clock
    ///
    /// Add seconds to the opponent's clock. Can be used to create games with time odds.
    ///
    ///
    /// - Remark: HTTP `POST /api/round/{gameId}/add-time/{seconds}`.
    /// - Remark: Generated from `#/paths//api/round/{gameId}/add-time/{seconds}/post(roundAddTime)`.
    internal func roundAddTime(_ input: Operations.roundAddTime.Input) async throws -> Operations.roundAddTime.Output {
        try await client.send(
            input: input,
            forOperation: Operations.roundAddTime.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/round/{}/add-time/{}",
                    parameters: [
                        input.path.gameId,
                        input.path.seconds
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.roundAddTime.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.roundAddTime.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Admin challenge tokens
    ///
    /// **This endpoint can only be used by Lichess administrators. It will not work if you do not have the appropriate permissions.** Tournament organizers should instead use [OAuth](#tag/OAuth) to obtain `challenge:write` tokens from users in order to perform bulk pairing.*
    /// Create and obtain `challenge:write` tokens for multiple users.
    /// If a similar token already exists for a user, it is reused. This endpoint is idempotent.
    ///
    ///
    /// - Remark: HTTP `POST /api/token/admin-challenge`.
    /// - Remark: Generated from `#/paths//api/token/admin-challenge/post(adminChallengeTokens)`.
    internal func adminChallengeTokens(_ input: Operations.adminChallengeTokens.Input) async throws -> Operations.adminChallengeTokens.Output {
        try await client.send(
            input: input,
            forOperation: Operations.adminChallengeTokens.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/token/admin-challenge",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.adminChallengeTokens.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.adminChallengeTokens.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.adminChallengeTokens.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.adminChallengeTokens.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Send a private message
    ///
    /// Send a private message to another player.
    ///
    ///
    /// - Remark: HTTP `POST /inbox/{username}`.
    /// - Remark: Generated from `#/paths//inbox/{username}/post(inboxUsername)`.
    internal func inboxUsername(_ input: Operations.inboxUsername.Input) async throws -> Operations.inboxUsername.Output {
        try await client.send(
            input: input,
            forOperation: Operations.inboxUsername.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/inbox/{}",
                    parameters: [
                        input.path.username
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.inboxUsername.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.inboxUsername.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get cloud evaluation of a position.
    ///
    /// Get the cached evaluation of a position, if available.
    /// Opening positions have more chances of being available. There are about 15 million positions in the database.
    /// Up to 5 variations may be available. Variants are supported.
    /// Use this endpoint to fetch a few positions here and there.
    /// If you want to download a lot of positions, [get the full list](https://database.lichess.org/#evals) from our exported database.
    ///
    ///
    /// - Remark: HTTP `GET /api/cloud-eval`.
    /// - Remark: Generated from `#/paths//api/cloud-eval/get(apiCloudEval)`.
    internal func apiCloudEval(_ input: Operations.apiCloudEval.Input) async throws -> Operations.apiCloudEval.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiCloudEval.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/cloud-eval",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "multiPv",
                    value: input.query.multiPv
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "variant",
                    value: input.query.variant
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiCloudEval.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiCloudEval.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CloudEval.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiCloudEval.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiCloudEval.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List external engines
    ///
    /// Lists all external engines that have been registered for the user,
    /// and the credentials required to use them.
    ///
    ///
    /// - Remark: HTTP `GET /api/external-engine`.
    /// - Remark: Generated from `#/paths//api/external-engine/get(apiExternalEngineList)`.
    internal func apiExternalEngineList(_ input: Operations.apiExternalEngineList.Input) async throws -> Operations.apiExternalEngineList.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineList.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEngineList.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEngineList.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ExternalEngine].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create external engine
    ///
    /// Registers a new external engine for the user. It can then be selected
    /// and used on the analysis board.
    /// After registering, the provider should start waiting for analyis requests.
    ///
    ///
    /// - Remark: HTTP `POST /api/external-engine`.
    /// - Remark: Generated from `#/paths//api/external-engine/post(apiExternalEngineCreate)`.
    internal func apiExternalEngineCreate(_ input: Operations.apiExternalEngineCreate.Input) async throws -> Operations.apiExternalEngineCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEngineCreate.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEngineCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ExternalEngine.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get external engine
    ///
    /// Get properties and credentials of an external engine.
    ///
    ///
    /// - Remark: HTTP `GET /api/external-engine/{id}`.
    /// - Remark: Generated from `#/paths//api/external-engine/{id}/get(apiExternalEngineGet)`.
    internal func apiExternalEngineGet(_ input: Operations.apiExternalEngineGet.Input) async throws -> Operations.apiExternalEngineGet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineGet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEngineGet.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEngineGet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ExternalEngine.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update external engine
    ///
    /// Updates the properties of an external engine.
    ///
    ///
    /// - Remark: HTTP `PUT /api/external-engine/{id}`.
    /// - Remark: Generated from `#/paths//api/external-engine/{id}/put(apiExternalEnginePut)`.
    internal func apiExternalEnginePut(_ input: Operations.apiExternalEnginePut.Input) async throws -> Operations.apiExternalEnginePut.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEnginePut.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEnginePut.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEnginePut.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ExternalEngine.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete external engine
    ///
    /// Unregisters an external engine.
    ///
    ///
    /// - Remark: HTTP `DELETE /api/external-engine/{id}`.
    /// - Remark: Generated from `#/paths//api/external-engine/{id}/delete(apiExternalEngineDelete)`.
    internal func apiExternalEngineDelete(_ input: Operations.apiExternalEngineDelete.Input) async throws -> Operations.apiExternalEngineDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEngineDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Ok.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Analyse with external engine
    ///
    /// **Endpoint: `https://engine.lichess.ovh/api/external-engine/{id}/analyse`**
    /// Request analysis from an external engine.
    /// Response content is streamed as [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON).
    /// The properties are based on the [UCI specification](https://backscattering.de/chess/uci/#engine).
    /// Analysis stops when the client goes away, the requested limit
    /// is reached, or the provider goes away.
    ///
    ///
    /// - Remark: HTTP `POST /api/external-engine/{id}/analyse`.
    /// - Remark: Generated from `#/paths//api/external-engine/{id}/analyse/post(apiExternalEngineAnalyse)`.
    internal func apiExternalEngineAnalyse(_ input: Operations.apiExternalEngineAnalyse.Input) async throws -> Operations.apiExternalEngineAnalyse.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineAnalyse.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine/{}/analyse",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEngineAnalyse.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEngineAnalyse.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Acquire analysis request
    ///
    /// **Endpoint: `https://engine.lichess.ovh/api/external-engine/work`**
    /// Wait for an analysis requests to any of the external engines that
    /// have been registered with the given `secret`.
    /// Uses long polling.
    /// After acquiring a request, the provider should immediately
    /// [start streaming the results](#tag/External-engine/operation/apiExternalEngineSubmit).
    ///
    ///
    /// - Remark: HTTP `POST /api/external-engine/work`.
    /// - Remark: Generated from `#/paths//api/external-engine/work/post(apiExternalEngineAcquire)`.
    internal func apiExternalEngineAcquire(_ input: Operations.apiExternalEngineAcquire.Input) async throws -> Operations.apiExternalEngineAcquire.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineAcquire.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine/work",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEngineAcquire.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiExternalEngineAcquire.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiExternalEngineAcquire.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 204:
                    let headers: Operations.apiExternalEngineAcquire.Output.NoContent.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    return .noContent(.init(headers: headers))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Answer analysis request
    ///
    /// **Endpoint: `https://engine.lichess.ovh/api/external-engine/work/{id}`**
    /// Submit a stream of analysis as [UCI output](https://backscattering.de/chess/uci/#engine-info).
    /// * The engine should always be in `UCI_Chess960` mode.
    /// * `UCI_AnalyseMode` enabled if available.
    /// * It produces `info` with at least:
    ///   - `depth`
    ///   - `multipv` (between 1 and 5)
    ///   - `score`
    ///   - `nodes`
    ///   - `time`
    ///   - `pv`
    /// The server may close the connection at any time, indicating that
    /// the requester has gone away and analysis should be stopped.
    ///
    ///
    /// - Remark: HTTP `POST /api/external-engine/work/{id}`.
    /// - Remark: Generated from `#/paths//api/external-engine/work/{id}/post(apiExternalEngineSubmit)`.
    internal func apiExternalEngineSubmit(_ input: Operations.apiExternalEngineSubmit.Input) async throws -> Operations.apiExternalEngineSubmit.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiExternalEngineSubmit.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/external-engine/work/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiExternalEngineSubmit.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    return .ok(.init(headers: headers))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Request authorization code
    ///
    /// OAuth2 authorization endpoint.
    /// Start the OAuth2 Authorization Code Flow with PKCE by securely
    /// generating two random strings unique to each authorization
    /// request:
    ///
    /// * `code_verifier`
    /// * `state`
    ///
    /// Store these in session storage. Make sure not to reveal `code_verifier`
    /// to eavesdroppers. Do not show it in URLs, do not abuse `state` to store
    /// it, do not send it over insecure connections. However it is fine if
    /// the user themselves can extract `code_verifier`, which will always be
    /// possible for fully client-side apps.
    /// Then send the user to this endpoint. They will be prompted to grant
    /// authorization and then be redirected back to the given `redirect_uri`.
    /// If the authorization failed, the following query string parameters will
    /// be appended to the redirection:
    ///
    /// * `error`, in particular with value `access_denied` if the user
    ///    cancelled authorization
    /// * `error_description` to aid debugging
    /// * `state`, exactly as passed in the `state` parameter
    ///
    /// If the authorization succeeded, the following query string parameters
    /// will be appended to the redirection:
    ///
    /// * `code`, containing a fresh short-lived authorization code
    /// * `state`, exactly as passed in the `state` parameter
    ///
    /// Next, to defend against cross site request forgery, check that the
    /// returned `state` matches the `state` you originally generated.
    ///
    /// Finally, continue by using the authorization code to
    /// [obtain an access token](#operation/apiToken).
    ///
    ///
    /// - Remark: HTTP `GET /oauth`.
    /// - Remark: Generated from `#/paths//oauth/get(oauth)`.
    internal func oauth(_ input: Operations.oauth.Input) async throws -> Operations.oauth.Output {
        try await client.send(
            input: input,
            forOperation: Operations.oauth.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/oauth",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "response_type",
                    value: input.query.response_type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "client_id",
                    value: input.query.client_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "redirect_uri",
                    value: input.query.redirect_uri
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "code_challenge_method",
                    value: input.query.code_challenge_method
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "code_challenge",
                    value: input.query.code_challenge
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "scope",
                    value: input.query.scope
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "username",
                    value: input.query.username
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "state",
                    value: input.query.state
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Obtain access token
    ///
    /// OAuth2 token endpoint. Exchanges an authorization code for an access token.
    ///
    ///
    /// - Remark: HTTP `POST /api/token`.
    /// - Remark: Generated from `#/paths//api/token/post(apiToken)`.
    internal func apiToken(_ input: Operations.apiToken.Input) async throws -> Operations.apiToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/token",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .urlEncodedForm(value):
                    body = try converter.setRequiredRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.apiToken.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiToken.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.apiToken.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Operations.apiToken.Output.BadRequest.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apiToken.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.OAuthError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Revoke access token
    ///
    /// Revokes the access token sent as Bearer for this request.
    ///
    /// - Remark: HTTP `DELETE /api/token`.
    /// - Remark: Generated from `#/paths//api/token/delete(apiTokenDelete)`.
    internal func apiTokenDelete(_ input: Operations.apiTokenDelete.Input) async throws -> Operations.apiTokenDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apiTokenDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/token",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    let headers: Operations.apiTokenDelete.Output.NoContent.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    return .noContent(.init(headers: headers))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Test multiple OAuth tokens
    ///
    /// For up to 1000 OAuth tokens,
    /// returns their associated user ID and scopes,
    /// or `null` if the token is invalid.
    /// The method is `POST` so a longer list of tokens can be sent in the request body.
    ///
    ///
    /// - Remark: HTTP `POST /api/token/test`.
    /// - Remark: Generated from `#/paths//api/token/test/post(tokenTest)`.
    internal func tokenTest(_ input: Operations.tokenTest.Input) async throws -> Operations.tokenTest.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tokenTest.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/token/test",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .plainText(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tokenTest.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.tokenTest.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Masters database
    ///
    /// **Endpoint: <https://explorer.lichess.ovh/masters>**
    ///
    /// Example: `curl https://explorer.lichess.ovh/masters?play=d2d4,d7d5,c2c4,c7c6,c4d5`
    ///
    ///
    /// - Remark: HTTP `GET /masters`.
    /// - Remark: Generated from `#/paths//masters/get(openingExplorerMaster)`.
    internal func openingExplorerMaster(_ input: Operations.openingExplorerMaster.Input) async throws -> Operations.openingExplorerMaster.Output {
        try await client.send(
            input: input,
            forOperation: Operations.openingExplorerMaster.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/masters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "play",
                    value: input.query.play
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "topGames",
                    value: input.query.topGames
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.openingExplorerMaster.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.openingExplorerMaster.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.OpeningExplorerMasters.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Lichess games
    ///
    /// **Endpoint: <https://explorer.lichess.ovh/lichess>**
    ///
    /// Games sampled from all Lichess players.
    ///
    /// Example: `curl https://explorer.lichess.ovh/lichess?variant=standard&speeds=blitz,rapid,classical&ratings=2200,2500&fen=rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR%20w%20KQkq%20-%200%201`
    ///
    ///
    /// - Remark: HTTP `GET /lichess`.
    /// - Remark: Generated from `#/paths//lichess/get(openingExplorerLichess)`.
    internal func openingExplorerLichess(_ input: Operations.openingExplorerLichess.Input) async throws -> Operations.openingExplorerLichess.Output {
        try await client.send(
            input: input,
            forOperation: Operations.openingExplorerLichess.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/lichess",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "variant",
                    value: input.query.variant
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "play",
                    value: input.query.play
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "speeds",
                    value: input.query.speeds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ratings",
                    value: input.query.ratings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "topGames",
                    value: input.query.topGames
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recentGames",
                    value: input.query.recentGames
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "history",
                    value: input.query.history
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.openingExplorerLichess.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.openingExplorerLichess.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.OpeningExplorerLichess.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Player games
    ///
    /// **Endpoint: <https://explorer.lichess.ovh/player>**
    ///
    /// Games of a Lichess player.
    ///
    /// Responds with a stream of [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON). Will start indexing
    /// on demand, immediately respond with the current results, and stream
    /// more updates until indexing is complete. The stream is throttled
    /// and deduplicated. Empty lines may be sent to avoid timeouts.
    ///
    /// Will index new games at most once per minute, and revisit previously
    /// ongoing games at most once every day.
    ///
    /// Example: `curl https://explorer.lichess.ovh/player?player=revoof&color=white&play=d2d4,d7d5&recentGames=1`
    ///
    ///
    /// - Remark: HTTP `GET /player`.
    /// - Remark: Generated from `#/paths//player/get(openingExplorerPlayer)`.
    internal func openingExplorerPlayer(_ input: Operations.openingExplorerPlayer.Input) async throws -> Operations.openingExplorerPlayer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.openingExplorerPlayer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/player",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "player",
                    value: input.query.player
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "color",
                    value: input.query.color
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "variant",
                    value: input.query.variant
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "play",
                    value: input.query.play
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "speeds",
                    value: input.query.speeds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "modes",
                    value: input.query.modes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "moves",
                    value: input.query.moves
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recentGames",
                    value: input.query.recentGames
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.openingExplorerPlayer.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.openingExplorerPlayer.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-ndjson"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-ndjson":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_ndjson(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// OTB master game
    ///
    /// **Endpoint: `https://explorer.lichess.ovh/masters/pgn/{gameId}`**
    ///
    /// Example: `curl https://explorer.lichess.ovh/masters/pgn/aAbqI4ey`
    ///
    ///
    /// - Remark: HTTP `GET /master/pgn/{gameId}`.
    /// - Remark: Generated from `#/paths//master/pgn/{gameId}/get(openingExplorerMasterGame)`.
    internal func openingExplorerMasterGame(_ input: Operations.openingExplorerMasterGame.Input) async throws -> Operations.openingExplorerMasterGame.Output {
        try await client.send(
            input: input,
            forOperation: Operations.openingExplorerMasterGame.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/master/pgn/{}",
                    parameters: [
                        input.path.gameId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.openingExplorerMasterGame.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.openingExplorerMasterGame.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-chess-pgn"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-chess-pgn":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_chess_hyphen_pgn(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Tablebase lookup
    ///
    /// **Endpoint: <https://tablebase.lichess.ovh>**
    /// Example: `curl http://tablebase.lichess.ovh/standard?fen=4k3/6KP/8/8/8/8/7p/8_w_-_-_0_1`
    ///
    ///
    /// - Remark: HTTP `GET /standard`.
    /// - Remark: Generated from `#/paths//standard/get(tablebaseStandard)`.
    internal func tablebaseStandard(_ input: Operations.tablebaseStandard.Input) async throws -> Operations.tablebaseStandard.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tablebaseStandard.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/standard",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.tablebaseStandard.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tablebaseStandard.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TablebaseJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Tablebase lookup for Atomic chess
    ///
    /// **Endpoint: <https://tablebase.lichess.ovh>**
    ///
    ///
    /// - Remark: HTTP `GET /atomic`.
    /// - Remark: Generated from `#/paths//atomic/get(tablebaseAtomic)`.
    internal func tablebaseAtomic(_ input: Operations.tablebaseAtomic.Input) async throws -> Operations.tablebaseAtomic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.tablebaseAtomic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/atomic",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.tablebaseAtomic.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tablebaseAtomic.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TablebaseJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Tablebase lookup for Antichess
    ///
    /// **Endpoint: <https://tablebase.lichess.ovh>**
    ///
    ///
    /// - Remark: HTTP `GET /antichess`.
    /// - Remark: Generated from `#/paths//antichess/get(antichessAtomic)`.
    internal func antichessAtomic(_ input: Operations.antichessAtomic.Input) async throws -> Operations.antichessAtomic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.antichessAtomic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/antichess",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fen",
                    value: input.query.fen
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.antichessAtomic.Output.Ok.Headers = .init(Access_hyphen_Control_hyphen_Allow_hyphen_Origin: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Access-Control-Allow-Origin",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.antichessAtomic.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TablebaseJson.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
